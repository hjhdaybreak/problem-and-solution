https://www.nowcoder.com/users/1409549  

SQL   

+ W G H O L   

+ 使用 group by 子句时，select 子句中只能有  聚合键、聚合函数、常数 

+ 使用 group by 子句，select 要查哪个，就可以加上 group by 哪个 

+ ```sql
  select[distinct]  
  from  
  join (如left join)   
  on  
  where  
  group by  
  having  
  union  
  order by  
  limit  
  ```

+ ```sql
  from  
  on  
  join  
  where  
  group by  
  having  
  select  
  distinct  
  union  
  order by 
  ```

  

# 场景题



**飞鸟问题**

**问题：**有一辆火车以每小时 15 公里的速度离开北京直奔广州，同时另一辆火车每小时 20 公里的速度从广州开往北京。如果有一只鸟，以 30 公里每小时的速度和两辆火车同时启动，从北京出发，碰到另一辆车后就向相反的方向返回去飞，就这样依次在两辆火车之间来回地飞，直到两辆火车相遇。请问，这只鸟共飞行了多长的距离？ 

**分析：**鸟在火车相遇前一直在飞，所以不论它如何往返，鸟飞的距离就是其速度乘时间，而时间则是用两列火车相遇的时间。设北京到广州的距离为 D，那么火车相遇时间是：D / (15+20)，由此可得鸟飞的距离是：30 * 时间 = 30/35 * D。 

**解答：**北京到广州距离的 30/35



**药丸问题     注意：污染是整个瓶子都污染**

-  **问题：**你有四个装药丸的罐子，每个药丸都有一定的重量，被污染的药丸是没被污染的药丸的重量+1。只称量一次，如何判断哪个罐子的药被污染了？  此时假设1粒药重为1克
-  **解答：**设未被污染的每个药丸的重量是x，则被污染的每个药丸的重量是x+1。将4个罐子分别标注为1，2、3、4，取一号罐子1个药丸，二号罐子2个药丸，三号罐子3个药丸，四号罐子4个药丸，一起称重。则： 

>   若一号罐子药丸被污染，则重量为（10x+1) 
>   若二号罐子药丸被污染，则重量为（10x+2) 
>   若三号罐子药丸被污染，则重量为（10x+3) 
>   若四号罐子药丸被污染，则重量为（10x+4)

 即称得的重量是10X+t，t 是几就是第几个罐子污染了



**开关问题** 

-  **问题：**门外三个开关分别对应室内三盏灯，线路良好，在门外控制开关时候不能看到室内灯的情况，现在只允许进门一次，确定开关和灯的对应关系？ 
-  **解答：**设三个开关是1、2、3。打开开关1等半个小时，关上开关1并打开开关 2。进房后去摸灯泡，热的是开关1对应的灯泡；亮的是开关2对应的灯泡；不亮不热的是开关3对应的灯泡



**诚实国和说谎国问题**

一个岔路口分别通向诚实国和说谎国。来了两个人，已知一个是诚实国的，另一个是说谎国的。诚实国永远说实话，说谎国永远说谎话。现在你要去说谎国，但不知道应该走哪条路，需要问这两个人。请问应该怎么问

只能问对每个人有不同正确答案的问题，问一个人说谎国往哪边走，另外一个人问他诚实国往哪边走 



**4人过桥问题** 

4 个人晚上要穿过一座索桥回到他们的营地。可惜他们手上只有一支只能再坚持17分钟的手电筒。通过索桥必须要拿着手电，而且索桥每次只能撑得起两个人的份量。这四个人过索桥的速度都不一样，第一个走过索桥需要1分钟，第二个2分钟，第三个5分钟，最慢的那个要10分钟。他们怎样才能在17分钟内全部走过索桥

第一和第二过去，二回来，一共 **4** 分钟；三四一起过去，一 回来  **11 ** 分钟， 一二一起过去  **2** 分钟 刚好  **17  **分钟  

一二一起去，一回来，共 3 分钟，三和四一起去，二回来 12 分钟，一二一起去 2分钟，共 17 分钟 





### 情景智力题       

### 二进制问题               

 **兔子试毒药 **      

有 1000 瓶药水，其中有一瓶是毒药，只要喝上一滴，一天之后就必死无疑



追求时间

+ 1000 只兔子



追求空间

+ 二分  1000 -> 500 -> 250 -> 125 -> 63 -> 32 -> 16 -> 8 -> 4 -> 2 -> 1，10 个箭头，就是10 次，也就是用了10 天，这样我们只用了 10 只兔子



中庸之道

+ 把 2 分，变成多分。比如，9 只兔子的话，每次能分 10 份，每轮补充兔子到 9 只 ，这样试完 1000 瓶药水，只需要 3天，1000 -> 100 -> 10 -> 1
+ 时间为 ： d = （logaN）    分 a 份，则兔子是 a - 1 只   药水 N 瓶



计算机思维   10 只兔子是可以标识 1000 瓶的 （2^10 = 1024）

+ 将 1000 瓶液体编号使用二进制表示，例如：2 用二进制表示就是 10，3 就是 11，1000 就是 11，1110，1000

  然后取 10 只兔子，第一瓶（1）喂给 1 号兔子喝，第二瓶（10）给 2 号兔子喝，第三瓶给 1，2 号兔子喝，以此类推，第1000瓶给第 4，6，7，8，9，10 号 兔子喝。这样就使用10 只兔子唯一的标识了1000 瓶液体 等到毒发，如果只有1号兔子死了，那么就是第一瓶，如果 1， 2  号都死了就是第三瓶



**分金块问题 ** 

工人为老板打工，工作七天可以获得一块金子，工人每天可以分得一点金子，老板必须每天发金子，不能多给，也不能少给，把这个金子切两刀，就可以每天给工人发工资，请问怎么切 (**切两刀**)

切两刀将金子分成三份，1/7、2/7、4/7     解题思路：要用金块拼凑出  1 ~ N 天，每天的收入，且金块和为 1 

比如15 天切三刀分成 1 / 15  2 / 15  4 / 15  8 / 15  



### 先手必胜问题

**抢 30**   

抢 30 是双人游戏 
游戏规则是：第一个人喊 "1" 或  "2"，第二个人要接着往下喊第一个或第二个数，然后再轮到第一个人。两人轮流进行下去。最后喊 30 的人获胜。问喊数字的最佳策略

+ 解析：倒着看，其实，喊 27 时，就决定胜负了。假设 A 喊了 27，B只能喊 28 或 29 ，下个回合，A 一定可以喊30。也就是说，喊 27 者必胜。再倒着看，其实喊 24 时，就定胜负了。假设 A 喊了 24 ，B 只能喊 25 或 26 ，下个回合 A 一定能喊 27 。由于喊 27 者必胜，因此喊 24 者也必胜。同理可以推出：**喊 3 的倍数者必胜**。然后就会发现，这个游戏，**谁先喊，谁一定输**  



**100 本书，每次能够拿 1~5  本，怎么拿能保证最后一次是你拿**

+ 如果最后一次是我拿，那么上回合最少剩下 6 本；只要保持每个回合结束后都剩下 6 的倍数，且在这个回合中我拿的书和对方拿的书加起来为 6 本；你先手，先拿走 4 本，创造剩余 6 的倍数本局面，剩下的你只需拿走 6-x 本 



### 推理题

**掰巧克力问题**

一块 N * M 大小的巧克力，每次掰一块的一行或一列，全部掰成 1 * 1 大小的巧克力需要掰多少次

不管怎么掰，每次只能把一个大块掰成两个小块，即每次掰只能增加1块巧克力； 那么将1块巧克力掰成 N * M 块小巧克力就需要掰N * M - 1次   举例子 2 * 2   需要掰 3 次 



**辩论赛问题**

1000个人参加辩论赛，1 对 1 进行辩论，淘汰输掉的一方，问需要安排多少场比赛才能角出冠军

每场辩论赛只能淘汰一个人，要淘汰 999 个人则需要安排 999 场比赛





**在 24 小时里面时针分针秒针可以重合几次**

24小时中时针走2圈，而分针走24圈，时针和分针重合 24 - 2 = 22 次，而只要时针和分针重合，秒针一定有机会重合，所以总共重合22次





**N  只蚂蚁走树枝，问总距离或者总时间**

这个其实就一个诀窍：蚂蚁相碰就往反方向走，可以直接看做没有发生任何事：大家都相当于独立的，A 蚂蚁 与 B蚂蚁相碰后你可以看做没有发生这次碰撞  



**旅馆的1元钱问题**

有三个人去住旅馆，住三间房，每 一 间房10元，于是他们一共付给老板 30，第二天，老板觉得三间房只需要25元就够了于是叫小弟退回 5 给三位客人，谁知小弟贪心，只退回每人1，自己偷偷拿了2，这样一来便等于那三位客人每人各花了九元，于是三个人一共花了27，再加上小弟独吞了不2，总共是29。可是当初他们三个人一共付出30那么还有$1呢？

他们所消费的27元里已经包括小弟贪污的2元了，再加退还的3元 = 30元； 这30元现在的分布是：老板拿25元，伙计拿2元，三人各拿1元，正好 ！





### 概率问题 

**两个人轮流抛硬币，正面获胜，先抛的人获胜的概率**  

第一次：正
第三次：反反正
第五次：反反反反正

p=1/2+(1/2)^3+(1/2)^5+ ······ +（1/2）^(2n+1)=1/2*(1+1/4+(1/4)^2+……+(1/4)^n)

![image-20220728000537950](G:\markdown图片\image-20220728000537950.png)

![img](G:\markdown图片\2020032921411620.png)



**家里有两个孩子，一个是女孩，另一个也是女孩的概率是多少** 

样本空间为（男男）（女女）（男女）（女男）     

A ＝（已知其中一个是女孩）＝（女女）（男女）（女男）   

B ＝（另一个也是女孩）＝（女女）   

于是 P（B／A）＝P（AB）／ P（A）＝（1／4）／（3／4）＝1／3



**组成三角形的概率**  

![image-20220219121145159](G:\markdown图片\image-20220219121145159.png)

x + y > a - x - y (x + y > a/2) 
x + a - x - y > y (y < a/2) 
y + a - x - y > x (x < a/2)   

一米长的绳子，随机切两刀，分成三段，求组合成一个三角形的概率

两边之和大于第三边，每个边的长度大于 0，小于 1，通过线性规划求解得到   1/4  



**一个圆上随机画两条弦，求相交的概率**

四个点确定两条线，在一个圆上取四个点； 四个点画两条线有三种情况，其中只有一种情况是相交的，故相交概率为 **三分之一**  

![image-20220204163720735](G:\markdown图片\image-20220204163720735.png)

**犯人猜颜色**  

一百个犯人站成一纵列，每人头上随机带上黑色或白色的帽子，各人不知道自己帽子的颜色，但是能看见自己前面所有人帽子的颜色，然后从最后一个犯人开始，每人只能用同一种声调和音量说一个字："黑" 或 "白" ，如果说中了自己帽子的颜色，就存活，说错了就拉出去斩了，说的答案所有犯人都能听见，是否说对，其他犯人不知道，在这之前，所有犯人可以聚在一起商量策略，问如果犯人都足够聪明而且反应足够快，100个人最大存活率是多少 

+ 最后一个人如果看到奇数顶黑帽子报 ''黑'' 否则报 ''白'' ，他可能死  
+ 其他人记住这个值（实际是黑帽奇偶数），在此之后当再听到黑时，黑帽数量减一  
+ 从倒数第二人开始，就有两个信息：记住的值与看到的值，相同报''白''，不同报 ''黑'' 
+ 99人能 100% 存活，1 人 50% 能活

变种题目  

每个奴隶只能看见前面一个人帽子颜色又能最多存活多少人？ 参考回答：增加限制条件后，上面的方法就失效了， 此时只能约定偶数位奴隶说他前一个人的帽子颜色， 奇数奴隶获取信息100%存活，偶数奴隶50几率存活 



**火枪手决斗，谁活下来的概率大**

+ 通过对两轮枪战的详细概率计算，我们发现枪法最差的丙存活的几率最大，枪法较好的甲和乙的存活几率却远低于丙的存活几率 



### 水桶问题

**水资源无限，3L 和 5L 水桶各一个，怎样取 4L 的水**

先往5升的水桶倒满水，将5升水桶里的水倒进3升水桶里，倒满后，5升水桶剩下2升水，将3升水桶里的水倒掉，将剩下的2升水倒进3升水桶里，3升水桶就会剩下1升水的空余位，降5升水桶倒满水后，往3升水桶里倒满，这个时候5升水有倒进了1升水，剩下4升水  





### 计时问题  

**利用烧绳子计算时间**

烧一根不均匀的绳，从头烧到尾总共需要 1 个小时   

**不均匀，所以并不是从一端烧到绳子的中间就是半个小时**

1. 度量30分钟：
   取一根绳子，从两端燃尽所需要的时间就是半个小时 
2. 度量15分钟：
   取两根绳子，第一根从一端燃烧，第二根从两端同时燃烧。当第二根燃尽的时候，将第一根剩余绳子从两端燃烧，第一根绳子剩余从两端燃烧耗尽所需要的时间就是15分钟 
3. 度量45分钟：
   采用上述方法所需的总时间就是45分钟（30+15）
4. 度量 75 分钟：30 + 45 就行了      





### 赛马问题 

**25 匹马找前三**     

![image-20211130201529993](G:\markdown图片\image-20211130201529993.png)

分五组，跑出每组第一， 五次， 所有第一再跑一次，6次， 得到下图，再跑一次，共 7 次  

![img](G:\markdown图片\AA35340A35DF0D8669A5D04EB14BE07A)

**有64匹马和8条跑道，每次只允许最多8匹马同时比赛（假定每匹马每次比赛速度相同），但是没有秒表不能计时，问最少要比多少次，才能选出最快的4匹马** 

第一轮 	总共比8场，淘汰每组后4名 

![img](G:\markdown图片\D3EE3F656BB6CB0507DFBBFCB310F5CB)

第二轮    在 8 组中选每组第 1 名的马进行比赛  

![img](G:\markdown图片\1B931997D72AA92FA5D94F049BAE476C)

![img](G:\markdown图片\A08398C35119AF16072C92BEA5E0B9F6)

A  已经晋级，固定为 第一名  

第三轮  A2-4、B1-3、C1-2、D1 这 9 匹马 (只有8条跑道) 中选择最快的3匹，同时知道B1>C1>D1， 这时D1是最危险的，因为已经知道有两匹马比它快，我们选择除了D1之外的 8 匹马进行比赛  

+ 如果 C1 以第三至七名的成绩完赛，除D1 这8匹马中的前三名就直接进入 TOP4  最少10场次 
+ 如果 C1 是第二，那么最终第三名（除D1比赛中的第三名）在 A2-4、B2-3、C2 中产生，并不能知道D1与它们的快慢，7 匹马 再比一场，第一晋级最多    8 + 1 + 1 + 1 = 11 场



#### 高楼扔鸡蛋

有**2个**鸡蛋，从100层楼上往下扔，以此来测试鸡蛋的硬度。比如鸡蛋在第9层没有摔碎，在第10层摔碎了，那么鸡蛋不会摔碎的临界点就是9层

问：如何用最少的尝试次数，测试出鸡蛋不会摔碎的临界点 

**简单粗暴**  

+ 最坏扔100次

**常规二分**  

+ 最坏50 次，50楼坏了，只有从1楼开始扔了  



**均衡切割**

我们是将100层切分成若干个区块，由第一颗鸡蛋确定最高安全楼层所属的区块，再由第二颗鸡蛋逐层确定其具体的位置

比如第一颗蛋每10层扔一次，第一次从10层扔，第二次从20层扔，第三次从30层扔……一直扔到100层。

第二颗蛋就只用在第一颗蛋摔碎的层数和前一次的安全层之间的9层进行范围遍历

最坏  最坏的情况是在第100层碎掉，总尝试次数为 10 + 9 = 19 次



**微妙平衡**

安全楼层位置越高，耗时就会越久，而第二颗鸡蛋在每个区块内的消耗，都是一样的

较低楼层；间隔大一些，楼层越高，间隔小一些；在最高安全楼层比较低的情况下，第一颗鸡蛋尝试的次数少；在最高安全楼层比较高的情况下，则第二颗鸡蛋尝试的次数少

我们假设第一个区块有X层，那么第二个就是X-1，以此类推，我们就得到了一个方程式：                                                         **X +（X-1）+（X-2）+···+3+2+1≥100**，向上取整  解得 X = 14，**总次数一定不会超过14次**

(1 + X) X = 200 

x + x^2 = 200  



#### 利用空瓶换饮料，最多喝几瓶

1000 瓶饮料，3个空瓶子能够换 1 瓶饮料，问最多能喝几瓶 

拿走 3 瓶，换回 1 瓶，相当于减少2瓶。但是最后剩下4瓶的时候例外，这时只能换1瓶 。所以我们计算 1000 减 2 能减多少 次，直到剩下4（1000 - 4 = 996，996 / 2 = 498）所以1000减 2 能减498次直到剩下4瓶，最后剩下的4瓶还可以换一瓶，所以总共是1000+ 498 + 1= 1499 瓶 



#### 抛硬币 

一枚正反概率不一样的硬币，如何当一枚正常的硬币来用 (正反概率相同) 

+ 连续抛两次，第一次为正面，第二次为反面  和 第一次为反面，第二次为正面  概率相同



#### 三人三鬼过河

有**三个人和三个鬼**要过河，河上没桥只有条小船，然后船一次只能渡一个人和一个鬼，或者两个鬼或者两个人，无论在哪边岸上，只要是人比鬼少的情况下(如两鬼一人，三鬼两人，三鬼一人)人会被鬼吃，然而船又一定需要人或鬼操作才能航行(要有人或鬼划船)，问，如何安全的把三人三鬼渡过河对岸



参考回答

每一轮都有五种过河选择，一人、一鬼、一人一鬼、两人、两鬼    **画一颗多叉树**

- 第一轮  两鬼过去，一鬼回来  
- 第二轮  两鬼去对岸，得回来一个   进入（3人1鬼 - 0人2鬼） 
- 第三轮  两人到对岸，此时（1人1鬼-2人2鬼），此时是平衡状态  只能是  一人一鬼 回来 （2人2鬼-1人1鬼）
- 两人去对岸，此时（0人2鬼-3人1鬼），此时只能让一只鬼独自撑船回去，（0人3鬼-3人0鬼）
- 鬼都过去

​	

#### 环回到原点问题 

一个环上有10个点，编号为 0-9，从 0点出发，每步可以顺时针到下一个点，也可以逆时针到上一个点，求：经过 n 步回到0 点有多少种不同的走法 

```java
//dp 
public class BackToOrigin {
    class Solution {
        public int backToOrigin(int n) {
            int len = 10;
            int[][] dp = new int[n + 1][len];
            dp[0][0] = 1;
            for (int i = 1; i <= n; i++) {
                // 注意这里j 从 0 开始
                for (int j = 0; j <= 9; j++) {
                    // dp[i] [j]  ,  表示 走 i 步 回到 j 点有多少种走法
                    dp[i][j] = dp[i - 1][(j - 1 + len) % len] + dp[i - 1][(j + 1) % len];
                }
            }
            return dp[n][0];
        }
    }
    
    // 递归
class Solution {
    int[][] mem = new int[11][11];
    public int backToOrigin(int n, int pos) {
        if (n == 0 && pos == 0) {
            return 1;
        }
        if (n == 0) {
            return 0;
        }
        if (mem[n][pos] != 0) {
            return mem[n][pos];
        }
        mem[n][pos] = backToOrigin(n - 1, (pos - 1 + 10) % 10) + backToOrigin(n - 1, (pos + 1 + 10));
        return mem[n][pos];
    }
}
```

#### 翻扑克

一个瞎子 52 张扑克牌，并告诉他里面恰好有 10张牌 是正面朝上的。要求这个瞎子把牌分成两堆，使得每堆牌里正面朝上的牌的张数一样多。瞎子应该怎么做 

+ 设 42 张中有 x 张正面朝上，则 10 张里面有10-x 张正面朝上 (故有x张朝下) ，这时将10张全部翻过来，两堆牌里都有x张正面朝上
  



#### 灯泡开关

一个圆环上有 100 个灯泡，灯泡有亮和暗两种状态。按一个灯泡的开关可以改变它和与它相邻两个灯泡的状态。 设计一种算法，对于任意初始状态，使所有灯泡全亮

从 1 循环到 98 ，遇到暗的则按它下一个，使之变亮。循环完毕，1 ~ 98 必然全亮。99 和 100可能为亮亮、暗亮、亮暗、暗暗四种状态   

+ 若为亮亮，皆大欢喜，满足题目要求 
+ 暗亮、亮暗，达到只剩一个为暗的状态
+ 若为暗暗。则按下编号 100 的灯泡，使编号 99 、100 变为亮，编号 1 的灯泡变为暗，从而达到只剩一个为暗的状态
+ 由于灯泡环形摆放，我们指定暗的灯泡编号为 1 ，将剩下 99 个亮着的灯泡每 3 个为一组。按下每组中间的灯泡后，使得所有灯泡变为暗
+ 将所有灯泡按一下，灯泡变为全亮  每个灯泡，会被改变三次，暗 - >  亮 - >  暗 - > 亮 



#### 砝码称轻重，找出最轻的

有一个天平，九个砝码，其中一个砝码比另八个要轻一些，问至少要用天平称几次才能将轻的那个找出来 

+ 至少2次。第一次，一边3个，哪边轻就在哪边，一样重就是剩余的3个；第二次，一边1个，哪边轻就是哪个，一样重就是剩余的那个； **至少称2次**



#### `贝叶斯公式应用 `

某城市有两种颜色的出租车：蓝色和绿色（市场占有比例为15∶85）。一辆出租车夜间肇事后逃逸，但还好当时有一位目击证人，这位目击者认定肇事的出租车是蓝色的。但是，他 "目击的可信度" 如何呢？公安人员在相同环境下对该目击者进行 "蓝绿"  测试得到：80%的情况下识别正确，20%的情况不正确。请问可以算出在有目击证人情况下肇事车辆是蓝色的概率为多少

![image-20220118203757897](G:\markdown图片\image-20220118203757897.png)事件 a 表示蓝车，b表示绿车，A表示看到的是蓝车，B表示看到的是绿车，故P(a)=0.15，P(b)=0.85，P(A|a)=0.8，P(A|b) = 0.2 

P (a|A) = P(a)P(A|a) / (P(A|a)P(a)+P(A|b)P(b)) = 0.150.8 / (0.150.8+0.20.85)=12/29 = 41.38% 





## 海量数据处理  

- bit：位
- byte：字节 
- 1 byte = 8 bit  
- int 类型为 4 byte，共 32 位 bit
- 2^32 byte = 4G 
- 1G = 2^30 byte = 10.7 亿  byte



#### Bloom Filter



#### Hash



####  Bit-Map

![image-20220203162451768](G:\markdown图片\image-20220203162451768.png)

适用范围：可进行数据的快速查找，判重，删除，一般来说数据范围是 int 的10 倍以下 

基本原理及要点：使用 bit 数组来表示某些元素是否存在，比如 8 位电话号码  

eg. 腾讯**判断 40 亿个QQ号码，哪些存活**  

+ byte 类型，可以看到，共有8位，取值范围是 [0，255] ，它能标识 0~7 这些数字都存在
+ 512 MB 大小足够标识所有QQ号码的存在与否，请注意：QQ号码的理论最大值为 2^32 - 1，大概是43亿左右

扩展：bloom filter 可以看做是对 bit-map 的扩展    

![img](G:\markdown图片\cd3f9c9055b78b11681ee8e84d7e3ef3.webp)



#### 堆

#### 双层桶划分

+ 因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行

#### 数据库索引

+ 适用范围：大数据量的增删改查

#### 倒排索引

适用范围：搜索引擎，关键字查询
基本原理及要点：为何叫倒排索引？一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。
　以英文为例，下面是要被索引的文本：
    T0 = "it is what it is"
    T1 = "what is it"
    T2 = "it is a banana"
    我们就能得到下面的反向文件索引：
    "a":      {2}
    "banana": {2}
    "is":     {0, 1, 2}
    "it":     {0, 1, 2}
    "what":   {0, 1}
　检索的条件 "what" ，"is" 和 "it" 将对应集合的交集



#### 外排序

+ 大数据的排序，去重

#### Trie 树

+ Trie 树在字典的存储，字符串的查找，求取海量字符串的公共前缀，以及字符串统计等方面发挥着重要的作用

#### MapReduce

+ 数据划分，结果归约



### 海量数据排序     

10GB 订单，按金额排序  

+ 多路归并   分成十个小文件，分别读取到内存排序（堆排序或快排）完毕放到文件，10个有序文件，开一个长度为10的数组，从每个文件读取一个数，找到数组中最小数字，放在一个新的文件，然后从最小数的文件取数，重复这个过程，减少IO可以加缓存，预先将数字方一部分到缓存 （K路归并） 
+ 桶排序   先对数据分区，划分成10个桶(文件)，桶分别排序，桶与桶有序，依次将桶中数据写入文件



### 海量数据查询   

10 亿个 IP 地址，查询某个 IP 是否在其中   

10 亿个 IP，每个 4B，共 4GB   

+ 位图     32位 ->  4字节  数据范围 0 ~ 2^32 - 1， 位图需要这么多二进制位  =  2^32 / 8 B = 500 MB 
+ Hash    分片   对每个 IP 先求 MD5 % 机器个数分到不同机器上； 对查询 IP 先求 MD5 然后 % 机器个数，到相应机器上查找



### 海量数据  TOPK   



**100 万个数找前  100  大**  

1. 根据快速排序划分的思想求解
2. 容量为100 的最小堆 
   + 顺序读取后续元素，直到结束。每次读取一个元素，如果该元素比堆顶元素小，直接丢弃 如果大于堆顶元素，则用该元素替换堆顶元素，然后保持最小堆性质。最坏情况是每次都需要替换掉堆顶的最小元素



10 亿个整数，求出现频率  Top 100  

+ 排序方式     先海量数据排序，扫描 100G 有序文件，统计频率， Top100  
+ Hash 分片   求MD5，分片到几台机器，分别扫描每台机器，统计关键字出现频率，写到小文件，形成多个小文件，顺序读入小文件，TOP 100  



### 海量数据去重      

10 亿条 URL 去重

+ 排序             海量数据排序， 每次读一批次，和上次读取不同的，加入写缓存，写缓存写满了，写文件
+ hash 分片    求MD5求余后分到不同机器，去重，合并 (相同URL肯定在同一机器)



**已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数**

位图  

+ 8位最多99 999 999，需要 100M 个bit 位，不到 12MB 的内存空间。我们把 0-99 999 999 的每个数字映射到一个 Bit 位上，这样，就用了小小的12M 左右的内存表示了所有的8位数的电话  

​    1 k = 10^3  1M = 10^6   100 000 000  = 100M  = 12.5 MB





### 两海量文件找重   

 两 4GB 文件找出相同 URL  

+ 海量数据排序 + 双指针   
+ 如果允许有一定错误率，可以使用布隆过滤器，将其中一个文件中的 URL 使用布隆过滤器映射，然后挨个读取另外一个文件的 URL，判断是否在布隆过滤器中存在
+ 求 Hash 值求余后放在多台机器上，多台机器上找重；求每对小文件中相同的 URL 时，可以把其中一个小文件的 URL 存储到 HashSet 中，然后遍历另一个小文件的每个 URL，看其是否在刚才构建的 HashSet 中，如果是，那么就是共同的URL 



### 海量整数的中位数   

求 N 个数的中位数(双层桶)

+ 依次遍历整数，按照其大小将他们分拣到 n 个桶中。如果有的桶数据量很小，有的则数据量很大，大到内存放不下了；对于那些太大的桶，再分割成更小的桶；之后根据桶数量的统计结果就可以判断中位数落到哪个桶中，如果该桶中还有子桶，就判断在其哪个子桶中，直到最后找出目标 



一共有N个机器，每个机器上有N个数，每个机器最多存 O(N) 个数，如何找到 N^2 个数中的中数

+ 先对每台机器上的数进行排序。排好序后，我们采用归并排序的思想，将这N个机器上的数归并起来得到最终的排序。找到第（N^2）/ 2个便是所求中位数   
+ 按照升序顺序把这些数字，Hash 划分为 N 个范围段。假设数据范围是2^32 的 unsigned int 类型。理论上第一台机器应该存的范围为 0~(2^32) / N，第 i 台机器存的范围是(2^32)`*`(i-1)/N~(2^32)`*`i/N。Hash 过程可以扫描每个机器上的 N 个数，把属于第一个区段的数放到第一个机器上，属于第二个区段的数放到第二个机器上，…，属于第N个区段的数放到第N个机器上 ；然后我们依次统计每个机器上数的个数，依次累加，直到找到第 k 个机器，在该机器上累加的数大于或等于（N^2）/ 2，而在第 k-1 个机器上的累加数小于（N^2）/ 2，并把这个数记为 x。那么我们要找的中位数在第 k 个机器中，排在第（N^2）/2-x 位。然后我们对第k个机器的数排序，并找出第（N^2）/ 2-x个数，即为所求的中位  



