操作系统-导论

https://document.ketangpai.com/?n=1&furl=http://ketangpai-test.oss-cn-hangzhou-internal.aliyuncs.com/ketangpai.aliapp.com/1/webroot/Uploads/Download/2022-03-13/622dc10aeb439.pdf?OSSAccessKeyId=LTAItfPkNIKJFibY&Expires=4818403555&Signature=puUnltVcXzq1t%2FKqPXF8im3MP%2B0%3D



进程管理上

https://document.ketangpai.com/?n=1&furl=http://ketangpai-test.oss-cn-hangzhou-internal.aliyuncs.com/ketangpai.aliapp.com/1/webroot/Uploads/Download/2022-03-31/62451f29a5838.pdf?OSSAccessKeyId=LTAItfPkNIKJFibY&Expires=4818403608&Signature=XQtOFyeCArCmIZMiNSqVXkyie%2B4%3D



进程管理下

https://openapiv5.ketangpai.com/PluginApp/to/id/MDAwMDAwMDAwMLOGsZiGqb9qhbh-3g/expires/4786867495/sign/5939e78b1cb589024bf67e36f8e7768a2ee152c7/token/641fdd7603faea02501bd563fb5ddf48afb1d9eb207a3c4e27752917b2d65d5b/uid/MDAwMDAwMDAwMLSGtZeHubdthNtyoQ.html



处理机调度与死锁 

https://openapiv5.ketangpai.com/PluginApp/to/id/MDAwMDAwMDAwMLOGsZiGqb9rhbh2lA/expires/4786867495/sign/0970222cea06d8aba31ad5a09a5aac6e00c03165/token/641fdd7603faea02501bd563fb5ddf48afb1d9eb207a3c4e27752917b2d65d5b/uid/MDAwMDAwMDAwMLSGtZeHubdthNtyoQ.html



存储管理

https://openapiv5.ketangpai.com/PluginApp/to/id/MDAwMDAwMDAwMLOGtd2IqcmwhM6glg/expires/4786867495/sign/fb529ab9ff955891df92a6cd414dac25f5987bae/token/641fdd7603faea02501bd563fb5ddf48afb1d9eb207a3c4e27752917b2d65d5b/uid/MDAwMDAwMDAwMLSGtZeHubdthNtyoQ.html

# 操作系统

## 操作系统启动

![image-20210629213511542](G:\markdown图片\image-20210629213511542.png)



CPU加电稳定之后，会对寄存器进行初始化，开始执行第一条指令，指令在内存中，内存分为RAM,ROM 
ROM加电之后保留的有原来写入的内容，系统初始化代码从那开始，第一条指令是跳转指令，跳转到BIOS

![image-20210629215443268](G:\markdown图片\image-20210629215443268.png)



![image-20210629220136447](G:\markdown图片\image-20210629220136447.png)

```tex
进入到BIOS执行,他是从磁盘上读取加载程序,在这个过程中
	硬件自检POST 
    检测关键的内存显卡等存在和工作状态 
    查找并执行显卡等接口卡BIOS 
    执行系统BIOS,进行系统检测 
    更新CMOS中的拓展系统配置数据ESCD (可以知道你是不是新插上什么卡,或者拔掉什么卡)

控制权转给读进来的加载程序,按照BIOS里面指定的顺序从软盘,硬盘,光盘或指定的其他设备上读进第一块主要引导扇区(有多个分区就一个主引导记录他包含启动代码(检查分区正确性、加载并跳转到磁盘上的引导程序) 和 磁盘分区表(用来描述磁盘信息、结束标志),跳到活动分区的引导扇区(包含跳转指令(跳转到启动代码(平台相关))、文件卷头(文件系统描述信息)、启动代码(跳转到加载程序)、结束标志),引导扇区读取文件系统加载程序,加载程序读取启动配置文件,启动菜单,加载指定的内核,最后转到内核执行,启动成功。
```

```tex
简单描述: CPU加电稳定之后,会对寄存器进行初始化,开始执行第一条指令,第一条跳转指令跳转到bios,bios读取主引导扇区,主引导扇区有主引导记录,根据主引导记录读取活动分区的引导扇区代码,引导扇区代码读取文系统加载程序,加载程序读取启动配置文件,列出启动菜单,我们选择启动参数,依据所选加载指定的os内核,最后跳转到内核执行,启动成功。
```



## 操作系统引论

所有讨论前提：单CPU，多任务，CPU能与外设并行

#### 什么是操作系统

OS是直接控制和管理计算机硬件、软件资源，合理地对各类作业进行调度，以方便用户使用的程序集合，他属于系统软件。



#### 操作系统的作用

作为用户和计算机间的接口，作为计算机系统资源的管理者，实现了对计算机资源的抽象(用户直接使用提供的接口无需了解物理接口的实现细节) 。

![image-20210629164749410](G:\markdown图片\image-20210629164749410.png)

#### 操作系统发展

无操作系统的计算机系统 

+ 手工操作阶段 

有操作系统的计算机系统 

1. 单道批处理系统 (等IO完成，资源利用率低)                      CPU空闲 
2. 多道批处理系统 (轮流使用，周转时间长，无交互能力)    CPU利用率提高了 
3. 分时系统(时间片 我们接触的)                                            可以交互了    **多路性**、**及时性**、**独立性**、**交互性**、可靠性
4. 实时系统 (硬实时性，软实时)       

![image-20221003223821328](G:\markdown图片\image-20221003223821328.png)



#### 操作系统的基本特性

1.并发          并发指两个或多个事件在同一时间间隔内发生   

2.共享          互斥共享方式(打印机)    同时访问方式(磁盘) 

3.虚拟技术   分时系统将一机虚拟为多机， 虚拟磁盘技术 磁盘分区(C,D,G)

4.异步性       速度不可预知



**共享性和并发性是最基本的两个特征**





## 进程管理

###  前趋图和程序执行

#### 程序的顺序执行(单道批处理系统)

一个程序由若干个程序段组成，这些程序段的执行必须是顺序的 (顺序,选择,循环 整体上是顺序执行) 

程序的顺序执行特性  

+ 顺序性(按程序规定的顺序)  
+ 封闭性(一旦开始，结果不再受外界影响，独占所有资源) 
+ 可再现性(结果只与初始条件有关) 

#### 前驱图 

 有向无环  用于描述进程之间执行的先后顺序 

![image-20210629165512980](G:\markdown图片\image-20210629165512980.png)

初始节点 终止节点  重量(节点执行时间)     前驱图中：无前驱关系可以并行 有前驱关系必须串行

#### 程序并发执行(多道批处理系统)

系统中N个作业，每个作业都有 I C P 三个阶段 流水线技术   

程序并发执行时的特征 
+ 间断性：多道程序之间相互合作，相互制约 "执行—暂停—执行"
+ 失去封闭性 
+ 不可再现性: 初始条件相同,得出的结果不同,引入进程来解决

![image-20210629172255244](G:\markdown图片\image-20210629172255244.png)

K：多少个作业，N：一个作业分成阶段，t：每个阶段所需要时间

单处理机系统中，可并行的是处理机与设备 处理机与通道 设备与设备    通道(只用于处理输入与输出的 "cpu")

###  进程的描述

#### 进程的特征

为什么引入进程 ?

+ 在多道程序设计的环境下，不能接受不可再现性。引入进程以在提高系统资源利用率的同时，保证可再现性。

什么是进程 ?

+ 进程定义：程序关于某个数据集合的一次执行过程。程序：音乐播放器 数据集合：歌

进程的特征 

1. 结构特征  进程控制块(PCB) + 程序+ 数据 = 进程实体   
2. 动态性     **最基本特征  因创建而产生，因调度而执行，因结束而消亡**

3. 并发性     (今后并发指的进程的并发，程序只能是顺序执行)  
4. 独立性     (独立运行,独立获取资源,独立接受调度的基本单位)   
5. 异步性    

进程：进程实体的一次执行过程，有生命周期。程序：程序是一组有序指令的集合，是静态的概念。

#### 进程的三种基本状态

1. 就绪状态(Ready)    进程已获得除CPU之外的所有必需的资源，一旦得到CPU控制权，立即可以运行。就绪队列
2. 运行状态(Running) 进程已获得运行所必需的资源，它正在处理机上执行。
3. 阻塞状态(Block)     根据不同阻塞原因,不同阻塞队列
4. 为了满足PCB对数据以及操作的完整性要求引入了 创建 终止

![image-20210629180116288](G:\markdown图片\image-20210629180116288.png)

![image-20210629180314633](G:\markdown图片\image-20210629180314633.png)

![image-20210629180407925](G:\markdown图片\image-20210629180407925.png)

A:  P(wait)操作: 申请资源的操作  本题ABC都从执行到阻塞 

#### 挂起操作(对换) 

挂起  释放内存过程

1. 终端用户的请求 
2. 父进程请求 
3. 负荷调节的需要 
4. 操作系统的需要 

​                了解

![image-20210629180742796](G:\markdown图片\image-20210629180742796.png)

活动就绪 -> 静止就绪  活动阻塞 -> 静止阻塞   静止就绪 -> 活动就绪 静止阻塞 -> 活动阻塞

#### 进程控制块（PCB）

进程控制块：存放  进程的  管理和控制 信息的数据结构 

进程控制块的作用 他是进程管理和控制的最重要的数据结构，在创建时，建立PCB，并伴随进程运行的全过程，直到进程撤消而撤消。PCB是进程存在的唯一标志   系统的所有PCB组织成链表或队列，常驻内存的PCB区。

进程控制块中的信息

+ 进程标示符 (内部标示符，外部标识符)   

+ 处理机状态 处理机的各种寄存器中的内容,进程能并发执行的原因

+ 进程调度信息  1.进程状态  2.进程优先级  3.进程调度所需的其他信息(为动态调整优先级记录信息提供依据(已执行时间、等待时间) 4.事件 由于什么事件而阻塞的 

+ 进程控制信息 1.程序和数据的地址  2.进程通信和同步机制  3.资源清单  4.链接指针(指向PCB队列的下一个PCB)

#### 进程控制块的组织方式

1. 线性方式(简单但查找时间长)   
2. 链接方式 把具有同一状态的PCB用其中的链接字链接成一个队列。
3. 索引方式 系统根据所有进程的状态建立几张索引表，把各表的内存首地址记录在内存的专用单元中,表目中记录了相应状态的某个PCB在PCB表中的地址  

### 进程控制 

**进程管理最基本功能** 

#### 操作系统内核 

将与硬件紧密相关的模块：中断处理程序、各种常用设备驱动程序以及运行频率高的模块（时钟管理、进程调度和模块公用部分）安排在紧靠硬件的软件层次中，将它们常驻用存，被称为 "内核" 。

处理机执行状态分为系统态和用户态

+ 系统态：运行OS内核      用户态：运行普通应用程序

用户态切换到内核态的3种方式

+ 中断、异常和系统调用

操作系统内核提供两方面功能

1. 支撑功能         中断处理 时钟管理(时钟脉冲 进程同步) 原语操作
2. 资源管理功能  进程管理 存储器管理 设备管理

#### 进程的创建

1. 进程树 

2. 引起创建进程的事件   1)用户登录  2)作业调度  3)提供服务  `123内核创建进程`    4)应用请求 `应用程序创建`

   `设备分配由相应进程提出申请，内核自动完成，只针对现有进程，不需要创建新进程` 

3. 创建进程过程  调用进程创建原语Creat() 创建新进程  (Window)

**申请空白PCB  为新进程分配资源  初始化进程控制块(优先级等)   将新进程插入就绪队列等待CPU调度**

------------------------------------------------------------------

Window CreateProcess 、Unix fork/exec  系统调用

fork是地址空间的复制

fork 一个进程复制成两个进程，父进程ID是原来执行进程的ID，子进程是新ID，fork 子进程返回pid为0，父进程返回子进程ID，根据返回的pid，子进程能进入exec的执行，换掉地址空间中的代码，加载的文件，父子就相互独立了

fork创建一个继承的子进程：子进程内存和变量，CPU寄存器与父进程一致，只有PID不同。

--------------------

#### 进程的终止

1.引起进程终止的事件

1)正常结束 2)异常结束  3)外界干预 -- 操作员干预 父进程请求 父进程终止

2.进程的终止过程

找出被终止进程的PCB -> 若进程状态为运行态，置CPU调度标志为真(以便CPU调度其他进程) -> 若其有子孙进程，终止其子孙进程并回收其资源 -> 回收终止进程的资源 -> 回收终止进程的PCB

#### 进程的阻塞(主动)与唤醒

调用阻塞原语block阻塞自己 -> 将PCB中的状态改为阻塞，并加入阻塞队列 -> 转进程调度(这时候CPU空闲)

阻塞进程等待的事件发生了，有关进程调用唤醒原语wakeup()唤醒等待该事件的进程。把阻塞进程从等待该事件的阻塞队列中移出 -> 置进程状态为就绪态，将PCB插入到就绪队列中。



### 进程同步  

什么是进程同步 : 对多个相关进程在执行次序上进行协调，使并发执行的进程之间能够有效共享资源和相互合作，使程序执行有可再现性。

#### 进程同步的基本概念  

进程间制约关系的两种形式

1) 源于共享资源的间接制约关系(打印机)         进程互斥(同时访问临界资源,要互斥的访问)

2) 源于合作的直接制约关系(生产者消费者)      进程同步(合作完成一件事情)    **资源信号量并不一定实现进程同步**

临界资源  : 一段时间只能由一个进程访问的资源,对临界资源必须互斥访问

临界区  : 访问临界资源的代码

如何设计访问临界区？ 先对临界资源访问标志进行检查，设置访问标志(进入区)，访问临界资源(临界区)，恢复标志为未被访问(退出区)，其余部分(剩余区)。

**进程互斥实质：两进程不能同时进入同一临界区**

同步机制应遵循的规则  空闲让进 忙则等待  有限等待 让权等待(不能进入临界区就释放CPU)



哪两种同步机制 

1. 硬件同步机制   关中断(只能单CPU，且影响效率)，Test-and-Set，Swap(XCHG)  都不遵循让权等待

2. 信号量机制       进程同步工具，同步指的广义同步包括互斥和合作 

信号量 (semaphore) 是由OS提供的管理公有资源的有效手段。  信号量代表可用资源实体的数量。例如互斥代表打印机（资源个数为1，互斥信号量），同步代表缓冲区中产品数量。  **只能赋初值，修改要通过P/V操作**    

1）整型信号量(wait(S) P(S) P操作)  (signal(S) V(S) V操作)  不遵循让权等待，导致忙等        

![image-20210909091923215](G:\markdown图片\image-20210909091923215.png)

2)  记录型信号量解决了让权等待问题，它增加了L链表，让资源不够时，申请资源的进程阻塞在 L 链表上

![image-20210703090133302](G:\markdown图片\image-20210703090133302.png)

数据结构(struct) 为 value+L (链表)  阻塞数量为value绝对值  

3) AND型信号量  能防止死锁   缺点：多个资源需要申请多次，每次只能申请释放一个资源，效率低

Swait 依次申请 Ssignal依次释放        S:同时操作的意思    前面的依次申请和释放是内部操作，但外部看来就是同时释放和申请  

4) 信号量集 

记录型信号量，每次只能申请释放一个资源，效率低；每次分配前需要测试资源数量，看是否大于其下界值，不大于则阻塞  

![image-20210703092208224](G:\markdown图片\image-20210703092208224.png)

一次性分配，一次性回收

S 为信号量；    t 为分配的下限值； d 为需求值                   S<t 就无法分配                

Swait(S,t,d)         

Swait(S, d, d)，只有一个信号量S，允许每次申请d个资源，若现有资源数少于d，不予分配。
Swait(S, 1, 1)，蜕化为一般的记录型信号量(S>1时)或互斥信号量(S=1时)。
Swait(S, 1, 0)，当S>=1时，允许多个进程进入某特定区，当S变为0后，阻止任何进程进入特定区，相当于可控开关。  



#### 信号量的应用  

信号量应用的三种模式  

下面所提到的互斥信号量和资源信号量是记录型信号量的不同分类方式，资源信号量不一定用来实现进程同步

1) 利用信号量实现进程互斥  2)利用信号量实现前驱关系   3)利用记录型信号量实现同步      

1. 利用记录型信号量实现两个进程互斥使用临界资源，为该资源设置互斥信号量mutex，其初始值一定是临界资源的数目,这里是1，将临界区CS置于wait(mutex)和signal(mutex)之间     wait(mutex)和signal(mutex) 一定要成对出现  

2. 利用信号量实现前驱关系     几条有向边,几个信号量,初始为0,从小到大依次分配信号量给有向边,每个节点 wait前驱  然后执行节点   signal后继   

3. 利用记录型信号量实现同步        ![image-20210705114518161](G:\markdown图片\image-20210705114518161.png)       

#### 管程

管程的定义

+ 代表共享资源的数据结构以及对该数据结构的一组操作
+ 定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程中的数据

管程比较进程

+ 进程是私有 管程是共享的数据结构 
+ 进程是为了程序并发执行，管程是为了解决共享资源的互斥使用，
+ 进程是动态的 管程是静态的
+ 进程能并发 管程不能 
+ 进程是主动工作方式  管程是被动工作方式

管程利用条件变量实现同步 

+ signal  
+ wait  

### 经典进程的同步问题  

同时有资源型信号量和互斥型信号量,必须先申请资源型信号量再申请互斥型信号量,否则可能死锁,释放顺序无限制

#### 生产者--消费者问题  

生产者进程和消费者进程都以异步方式运行(没有直接关系,你生产你的,我消费我的)，但它们之间必须保持同步(你生产了我才能消费,我没有消费导致你放满了,你不能再生产) 。  

利用记录型信号量解决生产者--消费者问题                                                                                                                          利用互斥信号量mutex实现诸进程对缓冲池的互斥使用；利用资源信号量empty和full分别表示缓冲池中空缓冲池和满缓冲池的数量   合作的关系,操作信号量出现在不同的程序段中。![image-20210705121008863](G:\markdown图片\image-20210705121008863.png)注意：在每个程序中的多个wait操作顺序不能颠倒。应先执行对资源信号量的wait操作，再执行对互斥信号量的wait操作，否则可能引起进程死锁。释放顺序没限制

利用AND信号量解决生产者--消费者问题  ![image-20210705121413871](G:\markdown图片\image-20210705121413871.png)对信号量操作无顺序要求

#### 哲学家进餐问题  

![image-20210707112807004](G:\markdown图片\image-20210707112807004.png)

解决方法：

1. 至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至少有一位哲学家能够进餐，用毕后释放出他用过的两只筷子，从而使更多哲学家能够进餐。
2.  规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子；偶数号哲学家则相反。
3.  仅当哲学家的左右两只筷子均可用时，才允许他拿起筷子进餐。  

一：利用记录型信号量 wait/signal 

![image-20210707112934584](G:\markdown图片\image-20210707112934584.png)

![image-20210707113011231](G:\markdown图片\image-20210707113011231.png)

二：利用AND型信号量 

![image-20210707113310823](G:\markdown图片\image-20210707113310823.png)

#### 读者--写者问题  

读写互斥,写写互斥,只能读读共享

1. 利用记录型信号量  

![image-20210707120958325](G:\markdown图片\image-20210707120958325.png)

2. 利用信号量集 

增加一个限制：最多只允许RN个读者同时读  

![image-20210707195157082](G:\markdown图片\image-20210707195157082.png)

Swait(S, 1, 0)，当S>=1时，允许多个进程进入某特定区，当S变为0后，阻止任何进程进入特定区，相当于可控开关。  

### 进程通信

四种进程通信方式  

同一台计算机的进程通信称为 IPC  （Inter-process communication）   

不同计算机需要通过网络，遵守共同的协议  

1) 共享存储器系统  2)消息传递系统  3)管道通信系统  4)客户机-服务机系统

1) 共享存储器系统 相互通信的进程之间共享某些数据结构(buffer) 或 共享存储区 量小

2) 消息传递系统   进程间的数据交换，以格式化的消息为单位 程序员使用系统提供的一组通信原语进行通信 例如网络报文

3) 管道通信  管道：指用于连接一个读进程和一个写进程以实现他们之间的通信的一个打开的共享文件,又称pipe文件

管道机制需要提供 互斥、同步、确定对方是否存在的协调能力。 

4)客户机-服务机系统 不同计算机之间相互通信，主流通信实现机制。Socket 、RPC远程过程调用  、RMI 远程方法调用

### 线程通信 

共享进程内的内存，通过线程通过访问同一个共享变量,来实现通信。(JAVA选择的)

消息传递 

### 线程

引入进程的目的  使多个程序能并发执行，提高资源利用率和系统吞吐量。  

引入线程的目的  减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性 ，也能提高资源利用率 

传统进程 是一个可拥有资源的独立单位 、可独立调度和分派的基本单位

线程是进程的一条执行路径，它包含独立的堆栈和CPU寄存器状态，每个线程共享其所附属的进程的所有的资源，包括打开的文件、页表、信号标识及动态分配的内存等等。  

#### 进程对比线程 

线程是属于进程的，线程运行在进程空间内，每个线程共享其所附属的进程的所有资源，当进程退出时该进程所产生的线程都会被强制退出并清除。  

调度       传统进程独立调度分派的单位  ->   线程是独立调度分派的基本单位

并发性     传统进程之间可以并发执行     ->   一个进程的线程可以并发,不同进程的线程也能并发执行,更高的并发性。

拥有资源 传统进程拥有、使用资源        ->   进程拥有资源,线程只拥有运行必不可少的资源 比如TCB，它使用所属进程资源

系统开销 传统进程创建 切换撤销 需要分配回收资源开销大 -> 线程创建切换系统开销小，切换速度快

#### 线程属性

1) 轻型实体 (为进程的一个实体）   基本上不拥有资源。只有一点必不可少的、能保证独立运行的资源   

2) 独立调度和分派的基本单位  

3) 可并发执行  

4) 共享进程资源  

#### 线程运行状态  

执行状态(某个线程获取cpu)  就绪状态  阻塞状态  

#### 多线程OS中的进程 

在多线程OS中，通常一个进程包括多个线程，每个线程是利用CPU的基本单位，是花销最小的实体，进程作为拥有系统资源的基本单位不再频繁切换，线程只拥有少量资源,它可以频繁切换，切换的时候不涉及资源分派和回收。

1) 作为系统资源分配的单位  2)进程不是一个执行的实体，但仍具有执行相关的状态  3)可包括多个线程  

#### 线程的实现

1. 内核级线程 1:1    1 KLT  1 LWP

   由操作系统内核直接支持的线程，由内核来完成线程的切换，内核通过操纵调度其对线程进行调度，并负责将线程的任务映射到各个处理器上，一个内核线程相当于一个内核，使操作系统能同时处理多个任务，程序一般不直接使用内核级线程，而是使用内核线程的一个高级接口——轻量级进程也就是我们说的线程

   缺点：线程操作都需要系统调用成本高， 一个LWP需要一个KLT支持占用内核资源

   ![image-20210712221939114](G:\markdown图片\image-20210712221939114.png)

   

2. 用户线程 1:N     1 P  N UT

   建立在用户线程的线程库上，线程操作都在用户态完成，没有内核干预，消耗低

   缺点：没有内核支持，线程操作必须由用户程序自己完成 还需要考虑很多问题 例如操作系统只把处理器资源分配到进程，那么阻塞如何处理，多处理器系统中如何将线程映射到其他处理器 

   ![image-20210712222459446](G:\markdown图片\image-20210712222459446.png)

   

3. 轻量进程和线程的混合实现 N:M

   ![image-20210712223639315](G:\markdown图片\image-20210712223639315.png)

   用户线程个轻量级进程一起使用，线程操作在用户态，不需要系统调用消耗低。用户线程可以通过LWP来使用内核提供的线程调度功能与处理器映射，减少完全阻塞可能。

## 处理机调度与死锁  

### 处理机调度的层次  

处理机调度的层次  

1. 高级调度  (作业调度)  只存在批处理系统中
2. 中级调度  (对换) 引入目的是为了提高内存利用率和系统吞吐量。应使暂时不能运行的进程不再占用内存，将它们调到外存去等待，具备条件时候再调入内存
3. 低级调度 (进程调度或短程调度) 用来决定就绪队列中的哪个进程应获得处理机  然后再由分派程序把处理机分配给该进程。  分时 批处理 实时系统都有

处理机调度算法的共同目标  

+ 资源利用率 CPU运行/CPU运行时间+等待时间
+ 公平性  公平性 所有进程都能利用CPU
+ 平衡性 CPU与外设负载均衡
+ 吞吐量 单位时间处理的作业数量
+ 策略强制执行  有需要的时候必须执行

1. 批处理系统目标    平均周转时间短 系统吞吐量高 处理机利用率高
2. 分时系统        响应时间快(提交请求到显示结果)   均衡性 （系统响应时间的快慢应与用户请求服务的复杂性相适应 ） 
3. 实时系统        截止时间的保证  可预测性  

周转时间  

+ 作业在外存后备队列上等待(作业)调度的时间  
+ 进程在就绪队列上等待进程调度的时间  
+ 进程在CPU上执行的时间  
+ 以及进程等待I/O操作完成的时间  

### 作业和作业调度  

作业(Job)  

JCB  作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。  

作业运行的三个阶段和三种状态  

+ 收容  运行  完成 
+ 后备状态   运行状态  完成状态  

作业调度的主要任务  

+ 根据内存大小接纳作业进入内存    
+ 根据进程的调度算法将作业从外存调入内存  

进程和作业调度算法

+ 先来先服务调度算法（ FCFS）         对短作业不利
+ 短作业(进程)优先调度算法（SJF）   有效降低作业的平均等待时间，提高系统吞吐量  
+ 优先级调度算法  
+ 高响应比优先调度算法   优先权=(等待时间+要求服务时间)/要求服务时间  
  + 等待时间相同短作业优先
  + 要求服务时间相同先来先服务
  + 对于长作业等待时间足够长也可获得处理机

### 进程调度  

进程调度的任务  

1. 保存处理机的现场信息  
2. 按某种算法选取进程  
3. 把处理机分配给进程  



进程调度机制

1. 排队器 根据进程调度算法把进程排队
2. 分派器 根据进程调度算法选出的进程，从就绪队列取出，然后进行从分派器到新选出进程之间的上下文切换，将处理器分配给新选出的进程 
3. 上下文切换器
   1.  将当前进程的处理机的状态保存保存到PCB中，装入分派器的上下文
   2. 将移除分派程序上下文，恢复选出进程的上下文到处理机器



进程调度方式  

1. 抢占式     时间片用完，优先级高，短进程抢占长进程
2. 非抢占式 `协程` 上下文切换次数少，系统开销小。只有在进程执行完毕，I/O请求，Wait操作才可能引起进程调度



进程调度算法

1. 时间片的轮转调度算法(RR) 

   + 系统将所有的就绪进程按FCFS的原则排成一个队列，每次调度时，把CPU分配给首进程，并令其执行一个时间片，当时间片用完但没有执行完毕又排到队尾
   + 分配时间要略大于一次交互时间 

2. 优先级调度算法  

   1. 静态优先权  创建进程时确定的  
   2. 动态优先权  比如高响应比优先算法

   确定进程优先权的依据  

   1. 系统进程 > 用户进程
   2. 资源要求少的高
   3. 用户要求 ：如果需要，可以按用户要求来设置，比如付费用户的优先级高。

3. 多级反馈队列调度算法   

   ![image-20210715154544758](G:\markdown图片\image-20210715154544758.png)

### 产生死锁的原因

产生死锁的原因和必要条件  

死锁 ：是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种状态时，若无外力作用，它们都将无法再向前推进。  

产生死锁的原因 

1. 竞争资源  
   1. 竞争不可剥夺性资源  打印机
   2. 竞争临时性资源         发送消息
2. 进程间推进顺序非法        请求和释放资源的顺序不当  比如消息先接收后发送，可以改成先发送后接受，就可以避免死锁 

系统中的资源分为两类 

1. 可剥夺性资源      可被高优先级进程剥夺
2. 不可剥夺性资源  进程用完后才释放  

产生死锁的必要条件  

1. 互斥条件   进程访问的是临界资源，即在一段时间内某资源只由一个进程占用。  
2. 请求和保持条件   获取了资源，申请另外资源失败阻塞，但不释放已有的资源
3. 不可抢占条件  
4. 环路等待条件   存在进程资源环   

处理死锁的基本方法 

1. 预防死锁 导致系统资源利用率和系统吞吐量降低。  
2. 避免死锁  银行家算法  (计算机使用的)
3. 检测死锁  
4. 解除死锁  撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程  

![image-20210716123452371](G:\markdown图片\image-20210716123452371.png)

ANS (3-1) + (4-1) + (5-1) +1

![image-20210716123533157](G:\markdown图片\image-20210716123533157.png)

ANS 至少两个 先从两个开始 p1 p2， p1 p3， p1 p4 然后三个， 四个依次判断 ANS为 3

### 预防死锁  

预防死锁：施加的限制条件较严格，往往会影响进程的并发执行。  

1. 破坏“请求和保持” 条件    资源足够一次分配，进程在运行期间不会提出资源要求    资源不够则进程等待
   + 实现简单，但是资源严重浪费，进程延迟执行
2. 破坏“不可抢占”条件         提出新的要求不被满足时必须释放它已经保持的所有资源，待以后需要时再重新申请 
   + 实现复杂，反复申请和释放等情况，延长了周转时间，增加系统开销。  
3. 破坏“环路等待”条件         将资源编号，按递增的次序提出申请
   + 为资源编号限制新设备的增加；  
   + 进程使用设备顺序与申请顺序不同，浪费资源
   + 限制用户编程自由



### 避免死锁  

系统安全状态  

1. 当系统处于安全状态时，一定不会发生死锁  
2. 当系统处于不安全状态时，可能发生死锁  

允许进程动态地申请资源，但在资源分配前，应先计算资源分配的安全性，若此次分配不会导致系统进入不安全状态，则
将资源分配给进程，否则，令进程等待。  

安全状态

是指系统能按某种进程顺序（P0, P1, P2, …, Pn） 来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成，若没有找到这样的一个序列则是不安全状态

+ 安全状态一定不会死锁 
+ 不安全状态可能死锁
+ 避免死锁的实质    系统在进行资源分配时，设法使系统不进入不安全状态。

#### 银行家算法 

![image-20210717114259952](G:\markdown图片\image-20210717114259952.png)

![image-20210717114321806](G:\markdown图片\image-20210717114321806.png)

![image-20210717114607093](G:\markdown图片\image-20210717114607093.png)

![image-20210717114635951](G:\markdown图片\image-20210717114635951.png)

![image-20210717114657227](G:\markdown图片\image-20210717114657227.png)![image-20210717114710789](G:\markdown图片\image-20210717114710789.png)

### 死锁的检测与解除  

死锁检测

资源分配图：使用资源分配图保存有关资源的请求和分配信息。

死锁定理：利用资源分配图来检测系统是否已进入死锁状态。    

1. 在图中找出既不独立也不阻塞的进程节点，让其顺序执行完毕释放资源
2. 由于释放资源，其他的进程能获得资源继续执行
3. 最终消掉所有的有向边则称该图是可完全简化的  

死锁定理: 状态为死锁状态的充分条件是当且仅当状态的资源分配图是不可完全简化的。 



死锁的解除

+ 从其他进程剥夺足够数量的资源  
+ 按照某种顺序逐个撤销进程 ，直至有足够的资源可用  或全部杀死

## 存储器管理

主要对象是内存

### 存储器的层次结构

![image-20210718094545334](G:\markdown图片\image-20210718094545334.png)

### 程序的装入和链接  

在多道程序环境下，要使程序运行，必须为之先建立进程。创建进程的第一件事是将程序和数据装入内存。  

将用户源程序变为可在内存中执行的程序的步骤  

1. 编译  编译程序源程序编译为目标模块 将 .c —>.obj

2. 链接  链接程序将编译后形成的一组目标模块，以及它们所需要的库函数链接在一起，形成一个完整的装入模块 

   .obj   ->  .exe 

3. 装入  由装入程序将装入模块装入内存，创建进程，分配资源

程序的链接 

1. 静态链接     程序运行前
2. 装入时动态链接  
3. 运行时动态链接  

程序的装入

1. 绝对装入方式             程序地址由编译时候给出，只用于单道程序环境  
2. 可重定位装入方式      静态重定位：装入内存时候要将装入地址+实地址，之后不能修改，不支持中级调度
3. 动态运行时装入方式  地址转换推迟到程序真正要执行时才进行，为了加速，设置重定位寄存器  支持中级调度

### 连续分配存储管理方式  

1. 单一连续分配   内存被分为系统区和用户区 只能单用户，单任务 Docs系统 

2. 固定分区分配   划分为固定的若干区域，使用分区说明表来记录分配情况   缺点内存碎片不能再分配(表项已使用)

3. 动态分区分配   内存中可利用空间不再连续，用数据结构管理起来

   1. 分区分配中的数据结构  空闲分区表  空闲分区链  已占分区说明表  

   2. 分区分配算法  

      1. 首次适应算法  **空闲分区表**以地址递增的次序排列，从表首开始顺序查找  

         + 优点保留了高地址大空闲区 缺点低地址部分产生小碎片 

      2. 循环首次适应算法NF(Next fit)(对上面改进)  从上次找到的空闲分区的下一个空闲分区开始查找 ，采用**采用循环查找**

         + 优点内存空间分配均匀 缺点缺乏大空间

      3. 最佳适应算法BF  **容量**以从小到大的顺序形成一**空闲分区链**

         + 缺点 产生许多难以利用的小空闲区  

      4. 最坏适应算法WF(worst fit) 空闲分区按其容量以**从大到小**的顺序形成一空闲分区链  

         + 优点：剩下的空闲区还可以利用，同时查找效率很高，一般第一个都能满足他。

         + 缺乏大的空闲分区。  

      5. 快速适应算法(quick fit)  将空闲分区**根据其容量大小**进行**分类**，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，在内存中设立一张管理索引表，该表的每一个表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。    

         + 优点 优点是查找效率高  ，不会产生内存碎片
         + 缺点 归还内存系统开销大，浪费空间(很多链表指针)

      空闲分区表产生内存碎片(无法利用)，空闲链表产生难以利用的小空间
      
   3. 分区分配及回收操作

      + 分配操作：从空闲分区链(表)中找到所需大小的分区。设请求的分区大小为u.size，表中每个空闲分区的大小表示为m.size，若m.size- u.size < size  则将整个分区分配给请求者，否则从分区中划出请求的大小，剩下的继续留在空闲链表中，返回分配区首地址给调用者

      + 回收操作

        四种情况       

   ![image-20210719101353110](G:\markdown图片\image-20210719101353110.png)

   ​			

   第一种，回收区与插入点的前一个分区邻接，将前一个分区的表项种分区大小改为两者之和                

   第二种，回收区与插入点的后一个分区邻接，直接将后一个分区的表项首地址，改为回收区的首地                                 址，大小改为两者之和

   第三种，回收区与插入点的前后分区邻接，将前面分区对应的表项中分区大小改为三者之和

   第四种，新键一个表目，首地为回收区首址，大小为回收区大小

   4. 可重定位分区分配  

      动态重定位分区分配算法  

      ​		相比动态分区分配算法，多了紧凑紧凑的功能
      
      ![image-20210719104730852](G:\markdown图片\image-20210719104730852.png)

### 对换  

阻塞进程不能运行但是占用大量内存，许多作业在外存而不能进入内存运行，通过对换把内存中暂时不能运行的进程或者暂时不用的程序和数据，调到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程和进程所需要的程序和数据调入内存

对换的分类 

1. 以进程为单位的整体对换

2. 以页或段为单位的页面对换或分段对换

   磁盘上划出对换区

   ![image-20210719111550955](https://i.loli.net/2021/09/15/oD3Z5UhnkRtgQFe.png)  

进程的换出与换入

1. 换出，选择优先级最低的阻塞态进程
2. 换入，选择已被换出的就绪状态进程

### 分页存储管理方式  

离散分配的基本单位是页

页面：将一个进程的逻辑地址空间分成若干个大小相等的片块  

块：内存空间被分成与页面相同大小的若干个存储块  

一种机器只能采用一种大小的页面，通常是1KB~8KB  

![image-20210720105808918](https://i.loli.net/2021/09/15/ibp2BARaHouT6rd.png)

页面大小 4KB  允许有1MB页，一种机器地址结构是一定的

+ 页号 P = INT[A/L]   地址为A   页面大小为L  
+ 页面地址(页内偏移量) d=[A] MOD L

页表：实现了从页号到物理块号的地址映射的页面映像表 ，每个进程都有一张，存放在内存中

页表寄存器(PTR)：存放页表在内存中的始址和长度，当进程被调度时候，从PCB保存入PTR中

![image-20210720110700620](https://i.loli.net/2021/09/15/dqlIO1gWBo7MhkY.png)

流程 通过逻辑地址算出页号，和PTR中页表长度比较，超过就触发越界中断，没有就通过页号在页表中找到对应块号，

块号+页内地址就得到在物理地址

因为要访问内存两次引入快表(寄存器) 一次访问内存

![image-20210720111126150](https://i.loli.net/2021/09/15/P8geZwNTK2FqMCb.png)

先去快表查找有无对应页号，有就直接得到物理地址，没有就正常流程，由于程序局部性原理，会将本次查找物理地址在页表中的页号块号保存到快表中



两级和多级页表 

现代操作系统支持的逻辑地址很大，页表很大需要连续存储空间，采用多级页表

![image-20210720113011835](https://i.loli.net/2021/09/15/af1DgVJSdqucmvQ.png)

![image-20210720113135627](https://i.loli.net/2021/09/15/qrdn4zVRC6eyvLg.png)

通过外部页号在外部页表计算出页表始址，再通过外层页内地址在页表中，找出对应的块号，块号+页内地址等于物理地址，三次访问内存

优点：减少页表所占的连续内存空间，有些是放在外存的



### 分段存储管理方式  

为什么要引入分段存储管理

+ 页是信息的物理单位。页的大小固定且由系统确定  ，他克服了外碎片，内存利用率高，但是导致了页内碎片
+ 逻辑完整的信息被分配到不同页面，导致执行效率低

分段：

+ 段是信息的逻辑单位。段的长度不固定，取决于用户程序，编译程序对源程序编译时根据信息的性质划分  。  
+ 含有意义相对完整的信息
+ 分页的作业地址空间是一维的；分段的作业地址空间是二维的。  

![image-20210721145716033](https://i.loli.net/2021/09/15/s8ufq749gBQi3yF.png)

该地址结构允许一个作业最长有64K个段，每段的最大长度为64KB 

![image-20210721145431641](https://i.loli.net/2021/09/15/hxR2cleOE16fuMd.png)

段号与段表长度比较，超过就触发越界中断，根据段寄存器记录的段表起始地址和段号找到段的起始地址和对应段长，如果位移量大于段长，触发越界中断，根据段起始地址和位移量计算出物理地址，访问内存，一共两次访问内存。



分段存储管理易于信息共享 

可重入代码又称为纯代码，是一种允许多个进程同时访问的代码，可重入代码不允许任何进程对它进行修改，可以每个进程配备一个数据区，将要修改的代码拷贝一份，程序执行时候只修改私有的数据区。



### 段页式存储管理方式  

将程序分成若干个段，再把每个段分成若干页，并为每个段赋予一个段名  

段页式系统地址结构：段号；段内页号；页内地址 

![image-20210721153523941](https://i.loli.net/2021/09/15/Y2bQPBTV7fOK39x.png)

段号与段寄存器中段长比较，超过越界中断，通过段表起始地址和段号计算出表项在内存的位置，读出对应段的页表始址和页表长度，再比较页号和页表长度，超过触发越界中断，通过页表始址和页号找到块号，块号加上页内地址得到物理地址，三次访问内存



## 虚拟存储器

常规存储器管理方式的特征 

1. 一次性   作业在运行前一次性地全部装入内存  
2. 驻留性   作业装入内存后，一直驻留在内存中，直到作业运行结束

程序运行的局部性原理：在一较短的时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域。

1. 时间局限性  
2. 空间局限性 

虚拟存储器的特征

1. 多次性：一个作业被分成多次调入内存运行  
2. 对换性：允许在作业的运行过程中进行换进、换出。  
3. 虚拟性：能够从逻辑上扩充内存容量   
4. 虚拟性以多次性和对换性为基础，多次性和对换性建立在离散分配的基础之上 

**虚拟存储器** 是指具有**请求调入**功能和**置换**功能，能从逻辑上对内存容量加以扩充的一种存储器系统。  

**存储容量**=内存容量+外存容量





### 请求分页存储管理方式 

请求分页系统是建立在基本分页基础上的，增加了请求调页功能和页面置换功能。  

请求分页中需要的硬件支持

1. 页表机制  

![image-20210723123228587](https://i.loli.net/2021/09/15/xznWZP7cMNwf42J.png)

2. 缺页中断机构

缺页中断与一般中断区别

1. 在指令执行期间产生和处理中断信号

2. 一条指令在执行期间，可能产生多次缺页中断。  如copy A To B 两个页都没在内存

   

3. 地址变换机构 

![image-20210724152330491](https://i.loli.net/2021/09/15/V9qo2lzmYbfd4hQ.png)



内存分配策略和分配算法  

最小物理块数：保证进程正常运行所需的最小物理块数。  

物理块的分配策略  

1. 固定分配局部置换    难以确定分配的物理块数

2. 可变分配全局置换    
+ OS自身也保持一个空闲的物理块队列，进程发生缺页时，从空闲的物理块队列取出，队列中的物理块用完后，OS从系统中的任一进程中选择一页调出。  
3. 可变分配局部置换 
+ 只允许从该进程在内存的页面中选出一页换出，不会影响其他进程执行。当他频繁缺页，OS会再给进程分
     配若干物理块。缺页率特别低，则适当减少分配给该进程的物理块。  

物理块分配算法 

1. 平均分配算法       缺点未考虑各进程本身的大小。  

2. 按比例分配算法   根据进程的大小按比例分配物理块。  

+ 先计算出系统中所有进程中页面数的总和 
+ 根据各个进程页面数占总页面数量比例分配物理块，计算结果物理块要取整，它必须大于最小物理块数。
3. 考虑优先权的分配算法   
+ 一部分按比例分配给各进程
+ 一部分则根据各进程的优先权，适当地增加其相应份额，分配给各进程。  



调页策略  

何时调入

1. 预调页策略          主要用于进程的首次调入时，例如双击应用程序启动时候
2. 请求调页策略       
   + 优：由请求调页策略所确定调入的页，一定会被访问；请求调页策略比较容易实现  
   + 缺：每次仅调入一页，需花费较大的系统开销，增加了磁盘I/O的启动频率。  

何处调入

请求分页系统中的外存分为文件区和对换区。  

1. 当系统拥有足够的对换区空间：可以全部从对换区调入所需页面，以提高调页速度。但需要把该进程文件拷贝到对换区。  
2. 系统缺少足够的对换区空间： 
   + 未被修改的页面不用换出，每次从文件区调入。
   + 被修改的页面换出时需调到对换区，换入时从对换区调入。  
3. UNIX方式  与进程有关的文件放在文件区，故未运行的页面应从文件区调入。曾经运行但又被换出的页面被放在对换区，下次调入应从对换区调入。进程请求的共享页面可能已被其他进程调入，无需再从对换区调入。  



### 页面置换算法  

在进程运行过程中，若其访问的页面不在内存而需将其调入，但内存已无空闲空间时，需根据**页面置换算法**从内存中调出一页程序或数据，送入磁盘的对换区。  

1. 最佳置换算法             无法实现，但可评价其他算法。

2. 先进先出置换算法      实现简单，但是与进程的实际运行规律不相适应(程序局部性原理)。

   + Belady现象  未分配进程所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的现象。  

3. 最近最久未使用(LRU)置换算法  

   **LRU置换算法的实现  **

   + 寄存器      进程有多少页面就有多少个寄存器，所有寄存器的同一位组成一组，每一组对应一个页面，当页面被访问的时候，置最高寄存器的相应位为1，隔一定时间所有组右移一位，高位补0，要淘汰时候淘汰最小的那个组对应的页面。

   + 栈           访问一个页面，如果页面号没有在栈内就入栈，在栈内就把他移动到栈顶。栈满的时候淘汰栈底元素。

  

4. **Clock置换算法** 

   最近未使用算法(NRU Not Recently Used)，与LRU 近似，又是对 FIFO 的⼀种改进  

   所有的页面都保存在⼀个类似钟面的「环形链表」中，⼀个表针指向最老的页面。  当发生缺页中断时，算法首先检查表针指向的页面：如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；  如果访问位是 1 就清除访问位，并把表针前移⼀个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；  

4. **改进型Clock置换算法**

   对于修改过的页面，在换出时所付出的开销比未修改过的页面大，置换代价大。    除须考虑页面的使用情况
   外，还须再增加一个因素--置换代价。 A访问位， M修改位。  

   1. 1类（ A=0，M=0）最近未被访问，未被修改  
   2. 2类（ A=0，M=1） 最近未被访问，已被修改  
   3. 3类（ A=1，M=0） 最近已被访问，未被修改  
   4. 4类（ A=1，M=1）最近已被访问， 已被修改  

   第一轮找第一类不做任何修改。第二轮找第二类，将所有扫描过的页面的访问位都置0。第三轮找第一类。第四轮找第二类。

5. 最少使用置换算法LFU（Least Frequently Used) 

![image-20210725195511756](https://i.loli.net/2021/09/15/Ul6QyM97cN1nAfq.png)

各组1的个数相加，淘汰最少访问的页面。



6. 页面缓冲算法(Page Buffering Algorithm)  

   页面分配算法                采用可变分配和局部置换的方式  

   页面替换算法用             FIFO   

   设置了空闲页面链表和修改页面链表。  换出时根据页面修改情况归入相应的链表末尾，并不换出内存以便下次访问。当已修改页面达到一定数目后，再将它们一起写回到磁盘上，归入空闲链表。
   
   

### 抖动与工作集  

抖动

+ 每个进程的大部分时间都用于页面的换进/换出，而几乎不能再去做任何有效的工作，从而导致发生处理机的利用率急剧下降并趋于0的情况。

发生抖动的原因  

+ 同时在系统中运行的进程太多，由此分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求，致使每个进程在运行时，频繁地出现缺页，必须请求系统将所缺之页调入内存。  

工作集  

+ 指在某段时间间隔里，进程实际所要访问页面的集合。虽然程序只需要少量的几页在内存便可运行，但为了较少地产生缺页，应将程序的全部工作集装入内存中。  

抖动的预防方法 

1. 采取局部置换策略    局部抖动，避免影响全局
2. 把工作集算法融入到处理机调度中 
   + CPU利用率低
     + 进程数量少，调入作业
     + 大量进程抖动，暂停进程 ，释放内存，降低其他进程缺页率，减少抖动发生。
1. 利用 "L=S" 准则调节缺页率  
   + L与S接近时，磁盘和处理机都达到最大利用率  
4. 选择暂停的进程  
   + 先暂停优先级低的

### 请求分段存储管理方式 

请求分段中的硬件支持 

1. 段表机制  

   ![image-20210726214133676](https://i.loli.net/2021/09/15/nObH3T6MeG8ahvu.png)

2. 缺段中断机构   

   ![image-20210726214410021](https://i.loli.net/2021/09/15/M3huar5T29iEYgJ.png)

3. 地址变换机构  

![image-20210726215034913](https://i.loli.net/2021/09/15/FfSAZVziITDRYdE.png)



分段的共享和保护

1. 共享段表

   在内存中配置一张共享段表，所有各共享段都在共享段表中占有一表项

![image-20210726215107520](https://i.loli.net/2021/09/15/2WADULEYykxK7JT.png)

2. 共享段的分配与回收 
   + 分配：第一次使用段的进程给它分配内存，设置count为1，后续其他进程只需要count+1。
   + 回收：最后一个进程释放它的内存空间，其他进程 count-1，当count=0时候回收内存空间。

3. 分段保护   

   + 越界检查   将段号与段表长度比较，段内地址与段长比较。  
   + 存取控制检查  
   + 环保护机构  环0：OS 核心   环1：操作系统服务  环3：应用程序 
     + 高优先级环可以访问同级和低优先级数据
     + 低优先级环通过调用同级或高优先级的服务

   

## 文件管理  

### 文件和文件系统  

现代 OS 中是通过文件系统来  组织 和 管理计算机中存储的数据 

文件则是指具有文件名的若干相关元素的集合

基于文件系统的概念，可以把数据组成分为数据项、记录和文件三级

![image-20210730162434622](https://i.loli.net/2021/09/15/aJluA4wR6Mf7mQP.png)

文件属性  

+ 文件类型   src obj exe
+ 文件长度  
+ 文件的物理位置  
+ 文件的建立时间  



文件名和扩展名  

+ 文件名 Window 不区分大小写  Linux 区分
+ 扩展名   指明文件类型



文件类型  

+ 按用途分类：系统文件、用户文件 和 库文件  
+ 按文件中数据的形式分类：源文件、目标文件 和 可执行文件  
+ 按存取控制属性分类：只执行文件、只读文件 和 读写文件  
+ 按组织形式和处理方式分类：普通文件、目录文件、特殊文件



文件系统的层次结构  

![image-20210730163013416](https://i.loli.net/2021/09/15/nGmFXqg4upbVYai.png)

1. 对象及其属性 ：文件管理系统的对象有：文件、目录和磁盘存储空间 。
2. 对对象操纵和管理的软件集合：对文件存储空间(磁盘)的管理、对文件目录(如何组织目录加快检索)的管理、文件的地址转换机制、对文件读写管理以及对文件的共享和保护  
3. 文件系统的接口   命令接口（用户与文件系统）保存新建按钮   和     程序接口（用户程序和文件系统 提供给程序员）open/read/write/close



![img](https://i.loli.net/2021/10/12/Gy1SERgV2dXPIfx.jpg)

文件操作 

`文件描述符fd在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。`

+ 文件的打开：指系统将指名文件的属性从外存拷贝到内存打开文件表的一个表目中，并将该表目的编号返回给用户。  以后当用户再要求对该文件操作时，便可利用系统所返回的索引号向系统提出操作请求。 此时可直接利用索引号到打开文件表中查找，避免了再次检索。  
+ 当用户不再需要对该文件实施相应的操作时，可利用 "关闭" 此文件， OS将会把该文件从打开文件表中的表目上删除  



### 文件的逻辑结构  

任何一个文件都有两种结构

+ 逻辑结构 (也称文件组织)          用户看到的文件形式
+ 物理结构 (也称文件存储结构)

文件逻辑结构

+ 有结构文件  如Excel表  根据记录长度分为定长记录文件和不定长记录文件
+ 无结构文件  由字符流构成的文件，也称流式文件

有结构文件

+ 顺序文件   记录是定长或可变长记录
  + 按逻辑记录的排序   串结构：各记录之间的顺序与关键字无关     顺序结构：文件中的所有记录按关键字排列  
  + 优点 适合批量操作  缺点 操作单个记录性能差
+ 索引文件   变长记录
  + 变长记录查找效率低，根据不同需求，按不同关键字建立索引加速查找
+ 索引顺序文件   
  + 手机联系人
+ 直接文件 
  + 哈希文件  利用Hash函数将关键字转换为相应记录的地址。  

无结构文件 

+ 流式文件    源程序、可执行文件、库函数  

+ UNIX          文件都被看做是流式文件  



### 文件目录 

文件目录也是一种数据结构，用于管理组织文件，标识系统中的文件及其物理地址，供检索时使用。  

目录管理要实现

+ 实现"按名存取"。
+  提高对目录的检索速度。
+  文件共享。
+  允许文件重名。  



FCB  用于描述和控制文件的数据结构，文件与文件控制块一一对应。文件管理程序借助文件控制块中的信息对文件施以各种操作。  包含

+ 基本信息类  
+ 存取控制信息类  
+ 使用信息类  



文件目录

+ 文件控制块的有序集合称为文件目录  

目录文件  

+ 文件目录也被看作是一个文件    

  

索引节点

检索目录文件的时候，需要将目录调入内存后比较文件名，只用到文件名，而不需要其它的文件描述信息。 避免将不需要的信息调入内存，故将文件名与文件信息分开，使文件描述信息单独形成一个索引结点，目录只需要包含文件名和索引结点编号或指针  

+ 磁盘索引结点  

+ 内存索引结点  



目录结构  

文件目录的组织形式

+ 单级目录  简单但是查找速度慢 ，不允许重名  ，不便共享
+ 两级目录  每个用户创建一个UFD，系统中再建立一个主文件目录MFD，MFD每个目录项指向UFD
+ 多级目录(树型目录结构) 大型系统
  + 路径名       
  + 当前目录   绝对路径：从根目录开始    相对路径：以当前目录开始



目录查询技术

查找打开文件的过程：当用户要访问一个已存文件时，系统首先利用用户提供的文件名对目录进行查询，找出该文件控制块或对应索引结点；然后根据FCB或索引结点中所记录的文件物理地址，换算出文件在磁盘上的物理位置；最后通过磁盘驱动程序，将所需文件读入内存。  

+ 线性检索法   单级目录顺序依次比对     树形目录根据路径名一级一级的查找   

+ Hash方法     建立了一张Hash索引文件目录，Hash方法进行查询  




## 磁盘存储器的管理  

### 文件存储空间的管理  

空闲表法和空闲链表法  

+ 空闲表法：系统为外存上的所有空闲区建立一张空闲表，每个空闲区对应一个空闲表项，其中包括表项序号、该空闲区的第一个盘块号、该区的空闲盘块数等信息。  再将所有空闲区按其起始盘块号递增的次序排列，形成空闲盘表。  
+ 空闲链表法：
  + 空闲盘块链  分配回收简单，以盘块为单位分配效率低
  + 空闲盘区链   一个盘区包含若干盘块



位示图法  

二进制的一位来表示磁盘中一个盘块的使用情况。当其值为"0"时，表示对应的盘块空闲； 为"1"时，表示已分配。  磁盘上的所有盘块都有一个二进制位与之对应，由所有盘块所对应的位构成一个集合，称为位示图。  

分配流程 

1. 顺序扫描位示图，找出一个或一组为"0"的二进制位  
2. 将所找到的二进制位转换成与之相应的盘块号。  第i行、第j列  盘块号  b = n(i-1)+j  n为每行的位数  
3. 修改位示图，令map[i,j] = 1  

盘块的回收 

1. 将回收盘块的盘块号转换成位示图中的行号和列号  i = (b-1)DIV n + 1   j = (b-1)MOD n + 1 n为每行的位数 
2.  修改位示图。令map[i,j] =0  



成组链接法  

概述：将盘块按100个为一组分组，100个盘块的最后一个盘块分成100份，每一份指向**下一组**的100个盘块。

有一个**空闲空闲盘块号栈**，最开始会指向第一组的每个盘块，用来分配，当分配完毕，会将第一组最后一个盘块的信息读入空闲空闲盘块号栈，开始继续分配第二组，以此类推。





## 中断 异常 系统调用

![image-20210701174308737](https://i.loli.net/2021/09/15/benT5PfOBWCJ4Kl.png)

为什么需要中断,异常和系统调用？

让计算机系统能对外界做出响应(中断)、应用程序执行错误,要由操作系统来处理(异常)、应用程序不被完全信任,但是应用程序需要使用操作系统内核提供的功能、所以操作系统内核需要提供外部调用的接口(系统调用)

![image-20211018200250553](G:\markdown图片\image-20211018200250553.png)

进程调用该共享段时，无需再为该段分配内存，只需要在进程的段表增加一表项，填写该共享段的物理地址







