## Java基础 

### Java 语言有哪些特点   

+ 面向对象   (封装，继承，多态) 
+ 平台无关性   (Java 虚拟机实现平台无关性)
+ Java 语言提供了多线程支持
+ 支持网络编程并且很方便   **BIO NIO  AIO**   网络编程框架  **Netty**
+ **编译与解释并存**   





###  JVM vs JDK vs JRE

####  JVM

Java 虚拟机（JVM）是运行 Java 字节码的虚拟机，针对不同的操作系统的JVM都有特定实现，但只要是使用相同的字节码，它们都会给出相同的结果；并且JAVA虚拟**提供语言无关性**，不只是JAVA，其他语言只要能编译成字节码，也能在JVM上运行。



**什么是字节码 ? 采用字节码的好处是什么 ? **

JVM解释执行的代码就叫做`字节码`（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。使用字节码使JAVA程序具有可移植，平台无关性 



![Java程序运行过程](G:\markdown图片\Java 程序运行过程.png)



**字节码和虚拟机是实现语言无关性的基础**



####  JDK 和 JRE

+ JRE  是 Java 运行时环境，它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，  Java 命令和其他的一些基础构件。但是，它不能用于创建新程序
+ JDK  是JAVA开发工具，它拥有 JRE 所拥有的一切，还有编译器和工具

###  

### 为什么说 Java 语言  "  编译与解释并存  "   

Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（`*.class` 文件），这种字节码必须由 Java 解释器来解释执行，JIT优化，它又会把.class的二进制代码编译为本地的代码直接运行，所以，又是编译的



### Oracle JDK 和 OpenJDK 的对比

+ OpenJDK 是一个参考模型并且是完全开源的，Oracle JDK并不完全开源 

+ Oracle JDK 与 OpenJDK 相比提供了更好的性能

+ Oracle JDK 比 OpenJDK 更稳定  



### Java  和  C++ 的区别   

+ 都是面向对象的**语言**，都支持封装、继承和 **多态**              **面向对象语言 !=  面向对象编程** 

+ Java 不提供指针来直接访问内存，程序内存更加安全，比如操作数组 
+ **Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承，JAVA也可以实现多继承，但是继承的层次越高，代码维护变得复杂，耦合性越高，应该面向接口编程，使用接口替代继承。 **
+ Java 有自动内存管理垃圾回收机制 (GC)，不需要程序员手动释放无用内存 
+ C ++  同时支持方法重载和操作符重载，但是 Java 只支持方法重载





###  Java 泛型

+ Java 泛型（generics）是 JDK 5 中引入的一个新特性，泛型提供了编译时类型安全检测机制，具有更好的安全性 。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数  

+ Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，变成裸类型，在元素访问的时候插入强制类型转换  
  
  + 伪泛型是为了保证向前兼容
  
+ 泛型三种使用方式，主要用于**容器类(集合)** 

  泛型类、泛型接口、泛型方法



​	JAVA为什么不实现的泛型 

+ JAVA语言规范承诺了保证向前兼容
+ 要实现泛型只能像 C#  一样，加入一套泛型化版本的新类型，但是JAVA已经很庞大了，加入导致语言的复杂性 
+ JAVA实现是将已有类型原地泛型化 ，将泛型化的实例类型 ArrayList<String>  成为裸类型ArrayList的子类 



**常用的通配符为**  T，E，K，V，？

本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些 **通常情况下，T，E，K，V，？ 是这样约定的：**

- ？ 表示不确定的 java 类型
- T (type) 表示具体的一个java类型
- K V (key value) 分别代表java键值中的Key Value
- E (element) 代表Element



泛型中有哪些类型参数的限定 

+ 上界为某个类              < U extends Number，V extends Number >   
+ 上界为某个接口          <T extends Comparable>   
+ 上界为其他类型参数   <T extends E >  



通配符的类型

+ <?  super   E >     超类型通配符   
+ < ? extend E >     有限定通配符  
+ < ? >                    无限定通配符  

1. < ? super E >  主要用于灵活写入或比较 ，能匹配父类型，使对象可以写入父类型的容器，父类型的比较方法可以应用于子类，不可以用类型参数替代 
2. < ? extend E >   < ? >  用于灵活读取 ，使方法可以读取 E 或 E 的子类的容器对象，可以用类型参数替代 



泛型的好处

+ 更好的安全性     泛型提供了编译时类型安全检测机制
+ 更好的可读性     没有泛型，就需要手动强制类型转换 




### hashCode 、equals 、==  

==  与  equals  的区别  

1. 对于基本类型来说，==  比较的是值是否相等  

2. 对于引用类型来说，==  比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）         

3. 对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；该 equals（）方法通常没有太大的实用价值，我们往往需要用重写 equals（）来判断 2个对象在**逻辑上是否等价**，而非验证它的唯一性。 

​              

为什么要有 hashCode 

+ hashCode 可以**快速判断**两个对象是否是不相等的 。 `Object` 的 hashcode 方法是本地方法，该方法通常用来将对象的内存地址转换为整数之后返回 

 为什么重写 `equals` 时必须重写 `hashCode`  方法 

+ 如果两个对象相等，则 hashcode 一定也是相同的，两个对象相等，对两个对象分别调用 equals 方法都返回 true 。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。 equals（）方法相等，hashcode（）必须相等，equals方法不相等，hashcode 可以相等，可以不相等，但是两者的一致有利于提高哈希表的性能 



为什么两个对象有相同的 hashcode 值，它们也不一定是相等的 

+ 与哈希函数好坏有关，hash函数越好，碰撞几率越小，hashcode相同几率也越小



### String   ==      之 StringTable 

StringTable(串池) 在运行时常量池中，JDK7从方法区移动到堆中。

```java
常量池中存放 常量和对象的引用

String s1 = "a";  假设他在长常量池中的第2项 
    
常量池最初存在于字节码文件,运行时加载到运行时常量池中,这时候都(仅)是常量池中的符号,还没变成java字符串对象,遇到ldc指令 a在常量池中的某一项(#2)  会把符号变为 "a" 字符串对象,然后准备好一片空间StringTable[] (刚开始是空的,数据结构是hash表),没找到"a",就把"a"字符串对象放入串池塘,用到这行代码才会开始创建这个字符串对象(ldc(加载) #2)(懒惰行为)。
    

String s1 = "a";
String s2 = "b";
String s3="ab"; 在串池
String s4 = s1 + s2; = new StringBuilder().append("a").append("b").toString()  在堆中
System.out.println(s3==s4); false 

String s4="a"+"b";在常量池中直接找到的已有"ab" javac在编译器的一个优化,编译期间结果已经确定为ab(都是常量)了
String s4 = s1 + s2; s1 s2是变量,在运行只可能被修改,结果不能确定,必须在运行期间用 StringBuilder 动态拼接
System.out.println("xxx");也会创建字符串对象放入串池,他是执行到这行才会创建。(字符串延迟加载)
```

注意区分 **new 的会放在堆中，不会主动放入串池，需要主动 intern **

## intern

```java
 String s1 = new String("a")
 String s2 = s1.intern()   
 s1==s2  1.6为 false  
         1.8为 true 

JDK 1.6 1.7 将这个字符串对象尝试放入串池,如果有则并不会放入,如果没有会把此对象复制一份,放入串池,会把串池中的对象返回	 放入串池的对象与调用intern的对象是两个对象。 副本和堆中不是一个
    
可以使用 intern 方法 , 主动将串池中还没有的字符串对象放入串池
1.8  将这个字符串对象尝试放入串池，如果有则并不会放入,如果没有则放入串池,会把串池中的对象返回。
```

StringT able GC 相关 

```java
1.7 从永久代到堆中, 永久代回收效率低(Full GC才会回收),间接导致StringTable回收效率低,容易导致永久代内存不足。
堆中Minor GC就会回收。  
    
往常量池灌字符串常量并且加入list,可以防止垃圾回收 

1.6 OOM(PermGen space) 
1.7 OOM(GC overhead limit exceede) 超过98%的时间用来做 GC 并且回收了不到 2% 的堆内存时会抛出此异常       如果关闭这个选项就是OOM(java heap space) 
```

StringTable性能调优

+ 数组(桶)越多，冲突小，查找速度越快，入池时间越短。调优就是调整桶的个数至少1009 -XX:StringTableSize=xxx
+ 考虑将字符串对象是否入池 (相同字符串，不会入池)去重 

**StringTable 底层类似hash表，数组(桶) + 链表**

​    

## JAVA 基本数据类型

+ 6 种数字类型 ：`byte`、`short`、`int`、`long`、`float`、`double` 
+ 1 种字符类型：`char` 
+ 1 种布尔型：`boolean`   

| 基本类型  | 位数 | 字节                  | 默认值  |
| --------- | ---- | --------------------- | ------- |
| `int`     | 32   | 4                     | 0       |
| `short`   | 16   | 2                     | 0       |
| `long`    | 64   | 8                     | 0L      |
| `byte`    | 8    | 1                     | 0       |
| `char`    | 16   | 2                     | 'u0000' |
| `float`   | 32   | 4                     | 0f      |
| `double`  | 64   | 8                     | 0d      |
| `boolean` | 1    | 逻辑上理解是占用 1 位 | false   |

+ 这八种基本类型都有对应的包装类分别为：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean`     
+ 包装类型不赋值就是 `Null `   而基本类型有默认值且不是 `Null`  
  + 基本数据类型直接存放在 Java 虚拟机栈中的局部变量表中，而包装类型属于对象类型，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小 ，所以有默认值



### JVM 基本数据类型

**局部变量表主要存放了编译期可知的基本数据类型 boolean、byte、char、short、int、float、long、double）**、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置），基本单位是槽 。  returnAddress 返回地址，被异常表取代。

 

###  自动装箱与拆箱

+ **装箱**：将基本类型用它们对应的引用类型包装起来； 调用了 包装类的`valueOf()` Integer.valueOf
+ **拆箱**：将包装类型转换为基本数据类型； `xxxValue()`方法  intValue 



###  8  种基本类型的包装类和常量池

+ `Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据 Cache 
+ `Character` 创建了数值在[0,127]范围的缓存数据                                                                                                   `Boolean` 在类加载的时候创建了  `True` Or `False` ，直接返回 True 或 False 
+ `Float`，`Double` 并没有实现常量池技术 
+ 如果超出范围，会创建新对象，因此 **所有整型包装类对象之间值的比较，全部使用 equals 方法比较**



## 方法（函数） 

###  方法有哪几种类型？ 

+ 无参数无返回值的方法

+ 有参数无返回值的方法

+ 有返回值无参数的方法

+ 有返回值有参数的方法

+ return 在无返回值方法的特殊使用

  ```
  public void f5(int a) {
      if (a > 10) {
          return;//表示结束所在方法 （f5方法）的执行,下方的输出语句不会执行
      }
      System.out.println(a);
  }
  ```



###  在一个静态方法内调用一个非静态成员为什么是非法的 

+ 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，只有通过类的实例对象才能访问 。在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作  




### 静态方法和实例方法有何不同

访问方式不同

+ 在外部调用静态方法时，可以使用 `类名.方法名` 的方式，也可以使用 `对象.方法名` 的方式，而实例方法只有后面这种方式



访问类成员是否存在限制

+ 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法）而实例方法不存在这个限制




### Java 中只有值传递 

+ 基本类型，传给方法的是拷贝的是基本的数值

+ 引用类型，传给方法的是拷贝的引用，通过引用修改引用指向的数据。如果在方法中交换引用指向的对象，交换的是拷贝的引用所指向的对象，不影响原来的引用 




###  重载和重写的区别   

重载： 编译时多态、同一个类中同名的方法具有不同的参数列列表、但不能根据返回类型进行区分，当重载版本不唯一，只能确定一个  "相对更合适的" 版本    按char>int>long>float>double的顺序转型进行匹配  

重写：运行时多态、发生在子类与父类之间、子类重写父类的方法并具有相同的返回类型、更好的访问权限  



####  重载

+ 发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。



在Java语言中，要重载（Overload） 一个方法， 除了要与原方法具有相同的简单名称之外， 还要求必须拥有一个与原方法不同的特征签名，而**返回值和访问修饰符不包含在特征签名之中**， 所以Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的 

但是在Class 文件中，返回值不同， 那么也是可以合法共存于同一个Class文件中，故在Class文件可以重载 



####  重写 

+ 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写 
+ 返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
+ 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明 
+ 构造方法无法被重写



**两同两小一大**

+ "两同" 即方法名相同、形参列表相同；
+ "两小" 指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
+ "一大" 指的是子类方法的访问权限应比父类方法的访问权限更大或相等。
+ 如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是**引用类型**，重写时是可以返回该引用类型的**子类**的  

JVM 中方法的调用是确定被调方法的版本，而不是指定方法体，方法调用分为解析和分派



#### 重载的原理

属于分派中的**静态分派(方法重载)，其实就是解析**，方法调用时有静态类型(外观类型) 和 实际类型(运行时类型)，编译器对于重载方法的选择，是根据传入参数的静态类型来选择的，在编译器结束就确定了方法的版本。方法的重载的都是通过静态分配来确定调用(解析调用)版本的  



#### 重写的原理

属于**动态分派**，执行到invokevirtual 指令，invokevirtual会找到操作数栈栈顶的第一个元素的所指向对象的实际类型。    先在实际类型中寻找匹配的方法，找不到便到父类中寻找，找不到AbstactMethodError。该指令不仅仅会把符号引用转化为直接引用，还会寻找接收者的实际类型    

**重载在类加载的解析阶段就将方法的符号引用转化成了直接引用，重写要在运行时确定了方法版本之后才能转成直接引用。**



#### 分派  

单分派与多分派，由宗量个数决定，方法的接收者、方法参数称为宗量，静态分派属于  静态多分派 由实际类型与方法参数两个宗量确定。

**JAVA 语言是一门静态多分派，动态单分派的语言**



#### 虚表

动态分派是通过**虚表**实现的，方法有虚方法表,接口方法有虚接口方法表，通过索引来找到各个方法的实际入口地址，父类和子类都有自己虚表，如果子类重写了父类的方法，那么子类的虚方法表中，入口会指向子类实现方法的版本的入口，没有实现则指向父类实现的方法版本入口



###  深拷贝 vs 浅拷贝

+ **浅拷贝**：对基本数据类型进行值传递，对引用数据类型进行引用传递的拷贝，此为浅拷贝。

+ **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝 。

+ String 和 基本数据类型一样可以，拷贝是深拷贝 



实现深拷贝

1. 序列化，再反序列化  

2. 实现Cloneable接口，并且重写Object类 clone()方法，在该方法中对对象和对象的每个成员属性调用clone()，并通过set方法设置成员属性   

   ```java
   Student student = (Student) super.clone();
   // 本来是浅复制，现在将Teacher对象复制一份并重新set进来
   student.setTeacher((Teacher) student.getTeacher().clone());
   return student;
   ```
   
   



## Java  面向对象 

### 面向对象语言与面向对象编程的区别  

+ 面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 

+ 面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言 



### 面向对象和面向过程的区别

**面向过程**  以过程 （可以理解为方法、函数、操作）作为组织代码的基本单元，数据(struct)（可以理解为成员变量、属性）与 方法相分离  

**面向对象** 它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 

**面向对象的优势  **  

1. OOP 更加能够应对大规模复杂程序的开发

2. OOP 风格的代码更易复用、易扩展、易维护 

3. OOP 语言更加人性化、更加高级、更加智能—— 不需要关注底层实现，只关注业务本身。



### 创建对象有几种方式  

+ new 关键字   

+ 使用反射方式创建对象，使用 newInstance()   

+ 使用 clone 方法   

+ 使用反序列化创建对象  

  

  


###  成员变量与局部变量的区别有哪些  

+ 语法       

  成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被`public`,`private`,`static` 修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 `final` 所修饰  

+ 从变量在内存中的存储方式  

  static 静态成员变量属于方法区，JDK7移动到堆中，类实例的成员变量在堆中；  局部变量在虚拟机栈中	 

+ 变量生命周期

  成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失

+ 变量是否有默认值 

  成员变量如果没有被赋初，则会自动以类型的默认值而赋值 ( final 修饰的成员必须显式赋值) ，而局部变量则不会自动赋值



### 创建一个对象用什么运算符    对象实体与对象引用有何不同  

new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）

###  对象的相等与指向他们的引用相等,两者有什么不同 

对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。



### 一个类的构造方法的作用是什么  若一个类没有声明构造方法该程序能正确执行吗    为什么

按程序员的意愿对类进行初始化，实例变量初始化，执行语句块。如果没有有提供任何构造函数，那编译器将会添加一个没有参数的、可访问性( public、 protected、 private 或 <package> )  与当前类型一致的默认构造函数 



### 构造方法什么时候调用  

为对象分配完堆内存，并初始化零值，对对象头进行必要的设置之后，执行 <init> 方法，该方法包含了构造方法。

<init>是在编译时生成的 



### 构造方法有哪些特点  是否可被 override 

+ 名字与类名相同 
+ 没有返回值，但也不能用 void 声明构造函数 
+ 生成类的对象时自动执行，无需调用 

构造方法不能被 override（重写），但是可以 overload（重载），所以你可以看到一个类中有多个构造函数的情况 。



### 面向对象三大特征



####  封装

+ 隐藏信息、保护数据，对类中属性的访问做控制，防止过度灵活不可控，到处可以修改，降低可读性、可维护性。只暴露必要的操作，能提高类的易用性。

####  继承

+ 代码复用  

+ 多重继承容易造成代码逻辑甚至业务逻辑的混乱，多重继承能带来的好处，可以通过扩展多个接口抵消掉大部分，易学易用，故JAVA不支持多重继承 

+ 层次过深入代码可读性、可维护性变差 

  

####  多态

+ 多态需要语法机制支持继承，重写，父类对象引用子类对象。

+ 实现多态
  1. 接口类语法 
  2. 继承加方法重写 
  3. 鸭子类型  JavaScript 它像个鸭子，它就是一个鸭子 
  
+ 可扩展性和复用性  

  

### String、StringBuffer 和 StringBuilder 的区别是什么 ? String 为什么是不可变的 ?

Copy-on-Write 才是最简单的并发解决方案。它是如此简单，以至于 Java 中的基本数据类型 String、Integer、Long 等都是基于 Copy-on-Write 方案实现的 

**可变性** 

+ `String` 类中使用 final 关键字修饰字符数组来保存字符串，`private final char value[]`，所以`String` 对象是不可变的。  修改发生时候保护性拷贝(创建新的对象副本从而避免共享)，保护性拷贝导致的问题就是创建过多的对象，解决办法就是利用享元模式。
+ `StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串`char[]value` 但是没有用 `final` 关键字修饰，所以这两种对象都是可变的。`StringBuilder` 与 `StringBuffer` 的构造方法都是调用父类构造方法 



**线程安全性** 

+ `String` 中的对象是不可变的 ，线程安全 
+ `AbstractStringBuilder` 是 `StringBuilder` 与 `StringBuffer` 的公共父类，定义了一些字符串的基本操作，如 `expandCapacity`、`append`、`insert`、`indexOf` 等公共方法。`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的 。

**性能** 

+ 每次对 `String`  类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。
+ `StringBuffer`   每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。
+ `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险 。
  1. 操作少量的数据: 适用 `String`
  2. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
  3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer` 



### Object 类的常见方法总结

+ getClass       返回当前运行时对象的Class对象
+ hashCode     用于返回对象的哈希码
+ equals          比较2个对象的内存地址是否相等
+ clone            要调用clone要实现 Cloneable接口并重写clone方法 
+ **finalize**        实例被垃圾回收器回收的时候由一个低优先级的Finalize 线程执行
+ toString()  返回类的名字  @实例的哈希码的16进制的字符串，建议Object所有的子类都重写这个方法 
+ **wait  notify  notifyAll  操作Java 对象关联的 Monitor  对象**



## 反射

+ 它赋予了我们在运行时分析类以及执行类中方法的能力
+ 通过反射你可以获取任意一个类的所有属性和方法，设置这些属性，调用这些方法 。
+ 造轮子必备 



###  反射机制优缺点

+ **优点** ：可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利
+ **缺点** ：
  
  + 性能降低
  
  + 可能会带来安全问题，通过反射我们可以越过访问控制修饰符的限制，也能无视 泛型类型安全  的检查
  
    

## 异常

在 Java 中，所有的异常都有一个共同的祖先 `java.lang` 包中的 `Throwable` 类。`Throwable` 类有两个重要的子类 `Exception`（异常）和 `Error`（错误）。`Exception` 能被程序本身处理(`try-catch`)， `Error` 是无法处理的(只能尽量避免) 。

+ **`Exception`**：程序本身可以处理的异常，可以通过 `catch` 来进行捕获。`Exception` 又可以分为 受检查异常(必须处理)  和 不受检查异常 (可以不处理) 。

+ **`Error`** ：`Error` 属于程序无法处理的错误 ，我们没办法通过 `catch` 来进行捕获 。例如，Java 虚拟机运行错误（`Virtual MachineError`）、虚拟机内存不够错误(`OutOfMemoryError`)  这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

  

**受检查异常** 

除了`RuntimeException`及其子类以外，其他的`Exception`类及其子类都属于受检查异常



**不受检查异常** 

`RuntimeException` 及其子类都统称为非受检查异常，例如：`NullPointerException`



###  Throwable   类常用方法

+ **`public string getMessage()`**: 返回异常发生时的简要描述

+ **`public string toString()`**    :返回异常发生时的详细信息

+ **`public void printStackTrace()`**:在控制台上打印 `Throwable` 对象封装的异常信息

  

### try-catch-finally   

+ **`try`块：** 用于捕获异常。其后可接零个或多个 `catch` 块，如果没有 `catch` 块，则必须跟一个 `finally` 块 

+ **`catch`块：** 用于处理 try 捕获到的异常 

+ **`finally`块：** 无论是否捕获或处理异常，`finally` 块里的语句都会被执行

  

**`finally` 块不会被执行**

+ 在 `try` 或 `finally`块中用了 `System.exit(int)` 退出程序 

+ 程序所在的线程死亡  

+ 关闭 CPU  

  

当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。 



### 使用 `try-with-resources` 来代替 `try-catch-finally`

+ 适用范围（资源的定义）： 任何实现 `java.lang.AutoCloseable`或者 `java.io.Closeable` 的对象

+ 关闭资源和 finally 块的执行顺序： 在 `try-with-resources` 语句中，任何 catch 或 finally 块在声明的资源关闭后运行 

+ 多个资源，用分号分隔

  

##  I/O流

### 什么是序列化  ?  什么是反序列化 ? 

+ 序列化：    将数据结构或对象转换成二进制字节流的过程
+ 反序列化：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程

**序列化的主要目的是通过网络传输对象或者是将对象存储到文件系统、数据库、内存中。**



### 如何实现序列化



将需要被序列化的类实现 Serializable 接口，该接口没有需要实现的方法，只是用于标注该对象是可被序列列化的，然后使用一个输出流（如： FileOutputStream）来构造一个 ObjectOutputStream 对象，接着使用 ObjectOutputStream 对象的 writeObject(Object obj) 方法可以将参数为 obj 的对象写出，要恢复的话则使用输入流  



### Java 序列化中如果有些字段不想进行序列化 ，怎么办 ？

对于不想进行序列化的变量，使用 `transient` 关键字修饰 

`transient` 关键字的作用是：阻止**实例**中那些用此关键字修饰的变量序列化；当对象被反序列化时，被 `transient` 修饰的变量值不会被持久化和恢复   

+ `transient` 只能修饰变量，不能修饰类和方法。

+ `transient` 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 `int` 类型，那么反序列后结果就是 `0`。

+ `static` 变量因为不属于任何对象(Object)，所以无论有没有 `transient` 关键字修饰，均不会被序列化。



###  获取用键盘输入常用的两种方法

+ Scanner     `nextLine()`会自动接收上方`nextInt()`的回车符，导致不能输入。用`next()`方法替换`nextLine()`方法。

+ BufferedReader 



###  Java 中 IO 流分为几种  ? 

+ 按照流的流向分，可以分为输入流和输出流；

+ 按照操作单元划分，可以划分为字节流和字符流；

+ 按照流的角色划分

  + 节点流   可以从一个点向另外一个点读写数据  这个点可以是数组，文件，管道等

  + 处理流   是对一个已存在的流的连接和封装比如缓冲流，转换流，数据流 

    

###  既然有了字节流,为什么还要有字符流?

`不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？`

因为字节流转换成字符流，过程很耗时。如果你必须要使用字符流，但你只得到了字节流，就**必须要经历**这个转换，其中编码也容易出问题 。 I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。

# Java 基础知识疑难点/易错点

## 基础

### 正确使用 equals 方法

+ null 是任何引用类型的默认值，不严格的说是所有 Object 类型的默认值 。
+ 不能使用一个值为 null 的引用类型变量来调用equals方法 
+ 推荐使用 java.util.Objects#equals   

### 整型包装类值的比较

+ 由于有缓存数据 Cache，所有整型包装类对象值的比较必须使用 equals 方法

### BigDecimal

+ **浮点数计算会出现精度丢失**，**使用 BigDecimal 来定义浮点数的值 ，再进行浮点数的运算操作。**并且使用构造参数为String 的构造函数构造

BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。

BigDecimal 的实现利用到了 BigInteger，所不同的是 BigDecimal 加入了小数位的概念



### 基本数据类型与包装数据类型的使用标准

+ 所有的 POJO 类属性必须使用包装数据类型。 考试成绩 0 和 null 是有区别的
+ RPC 方法的返回值和参数必须使用包装数据类型。 失败返回null，而不是默认值 
+ 所有的局部变量使用基本数据类型   反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。 





# 重要知识点

## 关键字总结

### final,static,this,super 

final  关键字，代表不可变，用来修饰类、方法和变量 

+ final  修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；
+ final  修饰的方法不能被重写；
+ final  修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量， 则在对其初始化之后便不能让其指向另一个对象。
+ `final 防止重写,在一定程度可以防止线程不安全发生 `



### static 关键字 

+ 修饰成员变量和成员方法
+ 静态代码块 
+ 静态内部类 
+ `静态导包`

#### `static{}`静态代码块与 `{}`非静态代码块(构造代码块) 

相同点： 都是在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行

![img](https://pic1.zhimg.com/80/v2-5c90f247eb462bf34bb47f71477c3ec6_720w.jpg?source=1940ef5c)

不同点：  

+ 静态代码块在非静态代码块之前执行(静态代码块 -> 非静态代码块 -> 构造方法)
+ **new** 或者 **`Class.forName("ClassDemo")` **会执行静态代码块，但只会执行一次，而非静态代码块在每 new 一次就执行一次 



### this 关键字

+ this 关键字用于引用类的当前实例(实例变量和实例方法) 

### super 关键字

+ super 关键字用于从子类访问父类的变量和方法



**注意** 

在构造器中使用 `super()` 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行 

this、super 不能用在 static 方法中



## 反射

赋予了我们在运行时分析类以及执行类中方法的能力，通过反射你可以获取任意一个类的所有属性和方法，并且可以设置属性调用方法。



反射的优缺点

+ 能够运行时动态获取类的实例(创建对象)，提高灵活性；   
+ 使用反射性能较低，需要解析字节码 



应用场景 

+ **框架中也大量使用了动态代理，而动态代理的实现也依赖反射。**

+ Java 中的 **注解** 的实现也用到了反射 





### 获取 Class  对象的四种方式

+ **知道具体类的情况下** Class alunbarClass = TargetObject.class

+ **通过 `Class.forName()`传入类的路径获取**  Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject");

+ **通过对象实例`instance.getClass()`获取**

+ **通过类加载器`xxxClassLoader.loadClass()`传入类路径获取**  

  Class clazz = ClassLoader.loadClass("cn.javaguide.TargetObject");

  **通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一些列步骤，静态块和静态对象不会得到执行 ** 
  
  



## 代理模式

在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。 注意不是增强。增强是装饰器模式的功能



### 静态代理 

+ **静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的 "重复" 代码**

+ **如果被代理类实现了接口，代理类和原始类需要实现相同的接口，通过委托的方式调用原始类来执行业务代码**

+ **没有实现接口，原始类不能修改，只有采用继承的方式，在类中调用 super.xxx()**



静态代理实现步骤 

1. 定义一个接口及其实现类 
2. 创建一个代理类同样实现这个接口
3. 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后附加功能 
4. **AspecJ就是静态代理 编译时编织  ** AspectJ 既有编译时也有运行时编织，SpringAop只有运行时



### 动态代理

不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。



**从JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的 。**



#### JDK 动态代理机制  

JDK动态代理  **`InvocationHandler` 接口和 `Proxy` 类是核心**

```
Proxy.newProxyInstance() 方法
传入loader :  类加载器，用于加载代理对象。
interfaces :  被代理类实现的一些接口;
h : 实现了 InvocationHandler 接口的对象;

必须需要实现InvocationHandler 来自定义处理逻辑, 当我们的动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler 接口类的 invoke 方法来调用。
```

原理

![image-20210820172638830](G:\markdown图片\image-20210820172638830.png)

com.sun.proxy.$Proxy 0  ( 1、2、3、4 依次递增)  

```java
newProxyInstance方法  传入类加载器,接口,和InvocationHandler。
调用Class<?> cl = getProxyClass0(loader, intfs),生成代理类。具体的过程是使用ProxyGenerator代理对象生成器,返回代理对象的字节码,调用 native 方法 defineClass0,底层会通过JAVA虚拟将字节码生成对应的类的Class对象。

    
这个类的父类是Proxy,并且实现了我们的接口。通过反射获取这个类带有InvocationHandler的构造函数,通过该构造函数与传进来的InvocationHandler创建代理对象,并将InvocationHandle传赋给父类属性。当我们调用方法的时候会被代理对象拦截,调用对应方法,方法内部会调用InvocationHandler的invoke方法,并将参数传递给InvocationHandler的invoke方法。
```



使用方法

+ 定义一个接口和实现类 
+ 自定义 `InvocationHandler` 并重写`invoke`方法，在 `invoke` 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；
+ 通过 `Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)` 方法创建代理对象；**接口就是我们定义的接口** 



#### CGLIB 动态代理机制

CGLIB (*Code Generation Library* 库) 是一个基于ASM 的字节码生成库，它允许我们在运行时动态生成和修改字节码

**在 CGLIB 动态代理机制中 `MethodInterceptor` 接口和 `Enhancer` 类是核心。**



使用方式

1. 定义一个目标类；
2. 自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法，和 JDK 动态代理中的 `invoke` 方法类似；
3. 指定 enhancer中的父类，也可以指定接口 ，指定回调MethodInterceptor，通过create 创建代理对象

```java
Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(superClass);
enhancer.setInterfaces(new Class[]{EchoService.class});
enhancer.setCallback(new MethodInterceptor() {
            @Override
            public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
                long startTime = System.currentTimeMillis();
                Object result = methodProxy.invokeSuper(proxy, args);
                long costTime = System.currentTimeMillis() - startTime;
                System.out.println("[Cglib 字节码] echo 方法执行时间" + costTime + "ms");
                return result;
            }
        });
EchoService echoService = (EchoService) enhancer.create();  生成代理对象
```



#### JDK 动态代理和 CGLIB 动态代理对比

+ **JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。**
+ JDK动态代理生成的是Proxy类的子类，而 CGLIB 动态代理是通过生成一个被代理类的子类，因此不能代理声明为 final 类型的类和方法
+ CGLIB 性能损耗比JDK大  



## IO模型

https://blog.csdn.net/MYLOVEis77/article/details/118159970?spm=1001.2014.3001.5501

同步阻塞IO、同步非阻塞IO、同步多路复用IO、异步阻塞（没有此情况）IO、异步非阻塞 IO，信号驱动 IO

+ 同步：线程自己去获取结果（一个线程）亲力亲为
+ 异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）



